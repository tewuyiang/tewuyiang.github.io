<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>博客主页</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tewuyiang.github.io/"/>
  <updated>2019-12-26T10:19:08.037Z</updated>
  <id>https://tewuyiang.github.io/</id>
  
  <author>
    <name>特务依昂</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高效算法求解数独</title>
    <link href="https://tewuyiang.github.io/%E9%AB%98%E6%95%88%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E6%95%B0%E7%8B%AC/"/>
    <id>https://tewuyiang.github.io/高效算法求解数独/</id>
    <published>2019-12-26T09:55:16.000Z</published>
    <updated>2019-12-26T10:19:08.037Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>&emsp;&emsp;之前上python课的时候，有一次实验是求解数独，要求时间复杂度要低；为此老师讲解了一个高效的数独算法，我觉得算法挺有意思的，写篇博客记录一下。</p><br><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>首先需要知晓数独的两个规则：</p><ol><li>若某个位置的值已经确定，那么，和这个位置在同一行，同一列，同一个3×3的格子，都不能填写这个值，比如，九宫格（1，1）位置的值为2，那么，第一行，第一列，以及第一个3×3的格子里，都不能在填2了；</li><li>若某一行，或者某一列，或者某一个3×3里面，只有一个位置可能填1（假如是1），那么1一定是填写在这个位置，因为没有其他位置可以填它了；、</li></ol><br><h4 id="求解步骤"><a href="#求解步骤" class="headerlink" title="求解步骤"></a>求解步骤</h4><ol><li><p>创建一个三维数组，假设就叫“可能值数组”，记录数独9×9的81个位置中，每个位置可能填写的值，初始情况下，每个位置的可能值都是1到9，表示每个位置都可能填写1-9中任何一个数字；</p></li><li><p>遍历数独的每一个位置，若某个位置已经有值，则将这个位置的可能值更新为这个值，比如，九宫格上，（1，1）的值已经确定是2了，那就将三维数组中（1，1）位置的可能值从[1-9]更新为[2]，直到所有的位置更新完毕；</p></li><li><p>使用上述规则1进行剪枝：</p><blockquote><p>（1）：从第一个位置开始遍历九宫格，若当前遍历到的位置（i,j），它的值已经知晓，那么就更新可能值数组，将第i行，第j列，以及其对应的3×3（【i/3×3 , j/3×3】就是这个3×3的第一个点）的所有位置，它们的可能值都要去除（i，j）位置的值；</p><p>（2）：若某个位置在经过上一步的剪枝后，可能值只剩下一个了，那这个位置的值就确定了，比如说，位置（1，1）的初始可能值是1到9，经过上面的一步步去除，只剩下一个3了，那这个（1，1）位置填写的值必定就是3了。此时我们可以再次使用规则1，即第一行，第一列，以及其对应的3×3中，所有的格子的可能值不能有3；</p><p>（3）：依次遍历每一个位置，使用上面的规则1，直到最后一格子，第一次剪枝便完成了；</p></blockquote></li><li><p>使用上面的规则2进行剪枝：</p><blockquote><p>（1）：统计每一行，每一列，以及每一个3×3中，每个数出现的次数，比如统计第一行每个格子的可能值，看1-9各出现几次，若某个可能值只出现一次，那出现这个值的位置，就是填写这个值，比如说，在第一行，3这个数字，只有（1，1）这个位置可能填写，那（1，1）就是填3，因为其他位置的可能值当中都不包含3，也就是都不能填写3；</p><p>（2）：根据上一步确定了某个位置的值后，那我们此时又可以使用规则1了，比如，上一步确定了（1，1）是填写3，那么第一行，第一列，以及第一个3×3中其余的格子， 都不能在写3了，我们从可能值数组中，将这些位置的可能，值删除3这个数；</p><p>（3）：而此时，又可能出现上面的第3步中的（3）的情况；</p></blockquote></li><li><p>规则2剪枝完毕后，数独还没有解决完毕，那我们只能通过枚举每一个位置的值，来一一尝试，直到找到最后的解决办法：</p><blockquote><p>（1）：我们在最开始创建了一个三维数组，存储每一个位置的可能值，初始情况下，每个位置的可能值都是1-9，但是经过上面两个规则的剪枝后，已经去除了很多；</p><p>（2）：此时我们使用DFS深度优先搜索，尝试为每一个位置填值。经过上面的剪枝，每个位置的可能值的数量应该不一样了，而为了减少DFS搜索的次数，我们应该从可能值最少的位置开始搜索；</p><p>（3）：遍历9宫格，找出还未填写值，且可能值最少的那个位置（可能有多个，找出第一个），尝试将他的第一个可能值填写在这个位置，然后再次调用规则1和规则2进行剪枝，剪枝完毕后，判断当前的九宫格中，是否有不和规则的地址，比如同一行出现两个一样的数。若没有不合法的地方，则再次进行一次（3），若有，表示这个位置不能填这个值，则从这个位置的可能值中再选择另外一个；</p><p>（4）：一直使用步骤（3），直到所有的位置都确定，则表示成功解出数独，若有某个位置，它的任何一个可能值填上去，都不能得到最终结果，那数独就是无解的；</p></blockquote></li><li><p>经过上面这些步骤，就能快速的解出数独，因为主要通过规则1，2进行剪枝，大大减少了枚举的次数，提升了效率；</p></li></ol><br><h4 id="所需计算"><a href="#所需计算" class="headerlink" title="所需计算"></a>所需计算</h4><ol><li>已知位置（i，j），则这个位置所在的3*3，其第一个点是（i/3×3 , j/3×3），i/3×3表示先作除法，去除了小数部分，再乘3，就是3的倍数了；</li><li>已知位置（i，j），如何计算这个位置属于第几个3×3，那就是（i/3×3 + j/3），每个3*3都占3行，且3列，i/3得到这个位置在第几个3行，j/3得到这个位置在第几个3列，每三行有三个3×3，所以i/3×3 + j/3就可以得到这个位置在第几个3×3；</li></ol><br><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>因为是为了完成python实验，所以代码是用python写的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此类用来表示搜索时，需要搜索的一个位置</span></span><br><span class="line"><span class="comment"># x，y为此位置的坐标，size为此位置的可能值的数量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y, size)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">        self.size = size</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取方式2，读取top95</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_way2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 从文件中读取初始数独</span></span><br><span class="line">    value = [[<span class="number">0</span>] * <span class="number">10</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">    <span class="comment"># 读取文件2，3</span></span><br><span class="line">    s = infile.readline();</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">''</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            value[i][j] = int(s[i * <span class="number">9</span> + j])</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">()</span>:</span></span><br><span class="line">    value = read_way2()   <span class="comment"># 读取top95</span></span><br><span class="line">    <span class="comment"># 初始化possibleValue，若当前位置有值，则其可能值就是这个值本身</span></span><br><span class="line">    <span class="comment"># 若没有值,则初始的可能值就是1-9</span></span><br><span class="line">    possibleValue = [[[] <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">if</span> value[i][j] != <span class="number">0</span>:</span><br><span class="line">                possibleValue[i][j] = [value[i][j]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                possibleValue[i][j] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> possibleValue</span><br><span class="line"></span><br><span class="line"><span class="comment">#####################################################################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据规则1进行剪枝</span></span><br><span class="line"><span class="comment"># 遍历所有的位置,找到已经确定的位置进行剪枝</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pruningByRule1</span><span class="params">(possibleValue)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">if</span> len(possibleValue[i][j]) == <span class="number">1</span>:</span><br><span class="line">                removeValueByRule1(i, j, possibleValue)    <span class="comment"># 以当前位置为起点,移除重复的可能值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在规则1剪枝中,将同一区域中,已经确定的数移除</span></span><br><span class="line"><span class="comment"># 以(i,j)位置为起点,移除重复的可能值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeValueByRule1</span><span class="params">(i, j, possibleValue)</span>:</span></span><br><span class="line">    <span class="comment"># 与当前值在同一行或同一列的位置，可能值减去当前位置的值</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">        <span class="comment"># 从第i行中的可能值列表中,移除当前值</span></span><br><span class="line">        confirmOneValueInRule1(i, k, possibleValue[i][j][<span class="number">0</span>], possibleValue)</span><br><span class="line">        <span class="comment"># 从第i列中的可能值列表中,移除当前值</span></span><br><span class="line">        confirmOneValueInRule1(k, j, possibleValue[i][j][<span class="number">0</span>], possibleValue)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 与当前值在同3*3的位置，可能值减去当前位置的值</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(int(i / <span class="number">3</span>) * <span class="number">3</span>, int(i / <span class="number">3</span>) * <span class="number">3</span> + <span class="number">3</span>):</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> range(int(j / <span class="number">3</span>) * <span class="number">3</span>, int(j / <span class="number">3</span>)* <span class="number">3</span> + <span class="number">3</span>):</span><br><span class="line">            confirmOneValueInRule1(k, l, possibleValue[i][j][<span class="number">0</span>], possibleValue)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除某个位置的可能值,并在移除后判断能否得到确定值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">confirmOneValueInRule1</span><span class="params">(i, j, num, possibleValue)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(possibleValue[i][j]) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 从当前位置的可能值中,移除已经确定的数</span></span><br><span class="line">    <span class="keyword">if</span> num <span class="keyword">in</span> possibleValue[i][j]:</span><br><span class="line">        possibleValue[i][j].remove(num)</span><br><span class="line">    <span class="comment"># 判断移除后,当前位置能否确定</span></span><br><span class="line">    <span class="keyword">if</span> len(possibleValue[i][j]) == <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># 若当前位置确定，则以当前位置为基准进行移除操作</span></span><br><span class="line">        removeValueByRule1(i, j, possibleValue)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">###########################################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据规则2剪枝,判断同一个区域每个值可能出现的次数</span></span><br><span class="line"><span class="comment"># 若某个值可能出现的位置只有一个,表示这个值就在此位置</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pruningByRule2</span><span class="params">(possibleValue)</span>:</span></span><br><span class="line">    <span class="comment"># 统计第i行，数字j可能值出现了几次</span></span><br><span class="line">    countX = [[<span class="number">0</span>] * <span class="number">10</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">12</span>)]</span><br><span class="line">    <span class="comment"># 统计第i列，数字j可能值出现了几次</span></span><br><span class="line">    countY = [[<span class="number">0</span>] * <span class="number">10</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">12</span>)]</span><br><span class="line">    <span class="comment"># 统计第i个3*3，数字j可能值出现了几次</span></span><br><span class="line">    countZ = [[<span class="number">0</span>] * <span class="number">10</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">12</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 统计各个区域可能值出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> possibleValue[i][j]:</span><br><span class="line">                countX[i][num] += <span class="number">1</span></span><br><span class="line">                countY[j][num] += <span class="number">1</span></span><br><span class="line">                countZ[i // <span class="number">3</span> * <span class="number">3</span> + j // <span class="number">3</span>][num] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断哪些数字只出现了一次, 若只出现了一次的数字</span></span><br><span class="line">    <span class="comment"># 表示这个数字就是那个位置的答案</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">            <span class="comment"># 若第i行数字j只出现了一次</span></span><br><span class="line">            <span class="keyword">if</span> countX[i][j] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">9</span>):  <span class="comment"># 遍历第i行的每一列，判断这个唯一值出现在哪</span></span><br><span class="line">                    confirmValueInRule2(i, k, j, possibleValue)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 若第i列数字j只出现了一次</span></span><br><span class="line">            <span class="keyword">if</span> countY[i][j] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">9</span>):  <span class="comment"># 遍历第i列的每一列，判断这个唯一值出现在哪</span></span><br><span class="line">                    confirmValueInRule2(k, i, j, possibleValue)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 若第i个3 * 3中，数字j的可能值只有一个</span></span><br><span class="line">            <span class="keyword">if</span> countZ[i][j] == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 遍历第i个3*3的所有位置，判断这个唯一值出现在哪</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(i//<span class="number">3</span>*<span class="number">3</span>, i//<span class="number">3</span>*<span class="number">3</span>+<span class="number">3</span>):</span><br><span class="line">                    <span class="keyword">for</span> l <span class="keyword">in</span> range(i%<span class="number">3</span>*<span class="number">3</span>, i%<span class="number">3</span>*<span class="number">3</span>+<span class="number">3</span>):</span><br><span class="line">                        confirmValueInRule2(k, l, j, possibleValue)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断当前位置是否包含某个数,包含则为此位置的答案</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">confirmValueInRule2</span><span class="params">(i, j, singleNum, possibleValue)</span>:</span></span><br><span class="line">    <span class="comment"># 若当前位置已经确定值了, 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> len(possibleValue[i][j]) ==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 若当前位置包含唯一可能值，则这个位置的确定值就是它</span></span><br><span class="line">    <span class="keyword">if</span> singleNum <span class="keyword">in</span> possibleValue[i][j]:</span><br><span class="line">            possibleValue[i][j] = [singleNum]</span><br><span class="line">            <span class="comment"># 重新调用规则1</span></span><br><span class="line">            removeValueByRule1(i, j, possibleValue)</span><br><span class="line"></span><br><span class="line"><span class="comment">###########################################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归搜索</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchForPruning</span><span class="params">(node, possibleValue)</span>:</span></span><br><span class="line">    <span class="comment"># 若没有需要填值的点了，表示搜索结束，答案已出</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> possibleValue</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取当前位置的x，y坐标</span></span><br><span class="line">    x = node[<span class="number">0</span>]</span><br><span class="line">    y = node[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> possibleValue[x][y]:</span><br><span class="line">        <span class="comment"># 复制一份当前状态</span></span><br><span class="line">        tempPossibleValue = copy.deepcopy(possibleValue)</span><br><span class="line">        <span class="comment"># 更新数据</span></span><br><span class="line">        tempPossibleValue[x][y] = [num]</span><br><span class="line">        <span class="comment"># 调用规则1，2</span></span><br><span class="line">        removeValueByRule1(x, y, tempPossibleValue)</span><br><span class="line">        pruningByRule2(tempPossibleValue)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 调用规则1，2后，判断当前结果是否合法，若合法，则进行递归下一层</span></span><br><span class="line">        <span class="keyword">if</span> judge_result(tempPossibleValue):</span><br><span class="line">            <span class="comment"># 递归求解</span></span><br><span class="line">            tempPossibleValue = searchForPruning(get_lowest_node(tempPossibleValue), tempPossibleValue)</span><br><span class="line">            <span class="comment"># 判断递归结果，若结果有返回值，则表示求解成功</span></span><br><span class="line">            <span class="keyword">if</span> tempPossibleValue <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> tempPossibleValue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前可能值最小的位置</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_lowest_node</span><span class="params">(possibleValue)</span>:</span></span><br><span class="line">    minn = <span class="number">100</span></span><br><span class="line">    node = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="comment"># 若当前位置没有确定值，并且可能值的数量更少，则更新记录，</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">1</span> &lt; len(possibleValue[i][j]) &lt; minn:</span><br><span class="line">                minn = len(possibleValue[i][j])</span><br><span class="line">                node = (i, j)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断某个位置是否可以放某个值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">judge_result</span><span class="params">(possibleValue)</span>:</span></span><br><span class="line">    <span class="comment"># 标记某个数字是否出现</span></span><br><span class="line">    countX = [[<span class="literal">False</span>] * <span class="number">10</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">12</span>)]</span><br><span class="line">    countY = [[<span class="literal">False</span>] * <span class="number">10</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">12</span>)]</span><br><span class="line">    countZ = [[<span class="literal">False</span>] * <span class="number">10</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">12</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 统计各个区域可能值出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">if</span> len(possibleValue[i][j]) == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 若当前状态不合法，返回false</span></span><br><span class="line">                <span class="keyword">if</span> countX[i][possibleValue[i][j][<span class="number">0</span>]] <span class="keyword">or</span> countY[j][possibleValue[i][j][<span class="number">0</span>]] <span class="keyword">or</span> countZ[i // <span class="number">3</span> * <span class="number">3</span> + j // <span class="number">3</span>][possibleValue[i][j][<span class="number">0</span>]]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="comment"># 若合法，则标记已经确定的数字</span></span><br><span class="line">                countX[i][possibleValue[i][j][<span class="number">0</span>]] = <span class="literal">True</span></span><br><span class="line">                countY[j][possibleValue[i][j][<span class="number">0</span>]] = <span class="literal">True</span></span><br><span class="line">                countZ[i // <span class="number">3</span> * <span class="number">3</span> + j // <span class="number">3</span>][possibleValue[i][j][<span class="number">0</span>]] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断某个位置是否可以放某个值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">judge_now_number</span><span class="params">(possibleValue, i, j, num)</span>:</span></span><br><span class="line">    <span class="comment"># 判断num在这一行和这一列是否被使用</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">        <span class="keyword">if</span> len(possibleValue[i][k]) == <span class="number">1</span> <span class="keyword">and</span> possibleValue[i][k][<span class="number">0</span>] == num:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> len(possibleValue[k][j]) == <span class="number">1</span> <span class="keyword">and</span> possibleValue[k][j][<span class="number">0</span>] == num:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 判断num在这个3*3是否被使用</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(int(i / <span class="number">3</span>) * <span class="number">3</span>, int(i / <span class="number">3</span>) * <span class="number">3</span> + <span class="number">3</span>):</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> range(int(j / <span class="number">3</span>) * <span class="number">3</span>, int(j / <span class="number">3</span>) * <span class="number">3</span> + <span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> len(possibleValue[k][l]) == <span class="number">1</span> <span class="keyword">and</span> possibleValue[k][l][<span class="number">0</span>] == num:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###########################################################################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出展示可能值列表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(possibleValue)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            print(possibleValue[i][j], end=<span class="string">"---"</span>)</span><br><span class="line">        print()</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line"><span class="comment">###########################################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    c = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 主逻辑</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 调用初始化函数</span></span><br><span class="line">        possibleValue = init()</span><br><span class="line">        <span class="comment"># 调用规则1剪枝</span></span><br><span class="line">        pruningByRule1(possibleValue)</span><br><span class="line">        <span class="comment"># 调用规则2剪枝</span></span><br><span class="line">        pruningByRule2(possibleValue)</span><br><span class="line">        <span class="comment"># display(possibleValue)</span></span><br><span class="line"></span><br><span class="line">        possibleValue = searchForPruning(get_lowest_node(possibleValue), possibleValue)</span><br><span class="line">        <span class="comment"># 判断是否有解</span></span><br><span class="line">        <span class="keyword">if</span> possibleValue <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            display(possibleValue)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"无解"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> judge_result(possibleValue):</span><br><span class="line">            print(<span class="string">"结果异常"</span>)</span><br><span class="line"></span><br><span class="line">        c += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> c &gt;= <span class="number">90</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    end = time.time()</span><br><span class="line">    print(end - start)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取本地存储文件</span></span><br><span class="line">infile = open(<span class="string">"D:/top95.txt"</span>)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><br><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>&emsp;&emsp;数独求解的算法，上面这种并不是最快的，还有一种叫做<strong>舞蹈链（Dancing Links）</strong>的算法，效率更高，有兴趣的可以了解一下；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;之前上python课的时候，有一次实验是求解数独，要求时间复杂度要低；为此老师讲解了一个高效的数独算法，我觉得算法挺
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://tewuyiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://tewuyiang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java创建List、Map等集合对象的同时进行赋值操作</title>
    <link href="https://tewuyiang.github.io/Java%E5%88%9B%E5%BB%BAList%E5%AF%B9%E8%B1%A1%E5%90%8C%E6%97%B6%E8%BF%9B%E8%A1%8C%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C/"/>
    <id>https://tewuyiang.github.io/Java创建List对象同时进行赋值操作/</id>
    <published>2019-11-28T15:25:47.000Z</published>
    <updated>2019-11-29T15:28:14.609Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题简介"><a href="#问题简介" class="headerlink" title="问题简介"></a>问题简介</h2><p>&ensp;&ensp;在Java当中，若希望在创建数组的同时给数组赋值很简单，可以想下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] num = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">String strs = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;但是，如果我们创建List集合，或者Map集合时，也想快速地为它赋初始值，应当如何做呢？</p><br><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><h4 id="方式1：调用函数"><a href="#方式1：调用函数" class="headerlink" title="方式1：调用函数"></a>方式1：调用函数</h4><p>&ensp;&ensp;请看如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"aa"</span>, <span class="string">"bb"</span>, <span class="string">"cc"</span>));</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;<strong><em>Arrays.asList(T… a)</em></strong> 方法的参数是一个可变长参数，也就是说他能够传入一个数组，也能够传入多个参数，而它的作用就是将传入的数组或多个数据封装成List集合返回，而上面的代码就是接收返回的List集合，并将其作为参数传入ArrayList的构造方法，创建一个新的ArrayList对象。</p><p>&ensp;&ensp;说到这里有人可能要问了，为什么不能直接将asList方法的返回值赋给list参数，而要将它传入构造器创建新的对象呢？这不是脱裤子放屁——多此一举吗。当然不是，请看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码1</span></span><br><span class="line">List&lt;String&gt; list1 = Arrays.asList(<span class="string">"aa"</span>, <span class="string">"bb"</span>, <span class="string">"cc"</span>);</span><br><span class="line">list1.add(<span class="string">"dd"</span>);    <span class="comment">// UnsupportedOperationException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码2</span></span><br><span class="line">String[] str = &#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(str);</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">"e"</span>;   <span class="comment">// list中的0号位置也一同改变</span></span><br></pre></td></tr></table></figure><p>&ensp;&ensp;上面有两段代码，看似没有问题，但是运行结果却和大家想象的有些不同。首先<em>代码1</em>，使用asList方法返回的创建的List对象，<strong><em>不允许进行修改操作</em></strong>，否则将会抛出一个<strong>UnsupportedOperationException</strong>；再来看<em>代码2</em>，我们将一个数组作为asList的参数，得到一个List对象，但是<strong><em>此时我们改变这个数组中元素的值，list对象的值也会发生改变</em></strong>，因为这个List对象底层引用的就是这个数组，并且和代码1一样，这个list也不能修改。</p><p>&ensp;&ensp;但是，若我们将返回的List对象作为参数传入ArrayList的构造器中，这个问题就不会发生，因为ArrayList的构造器将会把传入的list中所有的元素<strong><em>复制一份</em></strong>，因此不会影响到原数组，且可以随意改变。</p><br><h4 id="方式2：匿名内部类"><a href="#方式2：匿名内部类" class="headerlink" title="方式2：匿名内部类"></a>方式2：匿名内部类</h4><p>&ensp;&ensp;这是一个非常机智的方式，就是看到了下面这行代码，我才忍不住写了这篇博客：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;()&#123; &#123;add(<span class="string">"a"</span>); add(<span class="string">"b"</span>); add(<span class="string">"c"</span>);&#125; &#125;;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;乍一看是不是有点懵逼，我们将这段代码展开来看，就会清晰很多：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                add(<span class="string">"a"</span>);</span><br><span class="line">                add(<span class="string">"b"</span>);</span><br><span class="line">                add(<span class="string">"c"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;这下应该比之前容易理解了。这段代码就是创建了一个<strong><em>匿名内部类对象，且这个类继承自ArrayList</em></strong>，在这个匿名内部类中添加了一个<strong>非静态代码块</strong>，并在代码块中<strong>调用了三次add方法</strong>，为这个List对象赋值。</p><p>&ensp;&ensp;我们知道，若我们想创建一个对象，可以直接<strong><em>new 构造方法</em></strong>，但是我们若想写一个匿名内部类，这个匿名内部类继承自某个类，只需在<strong><em>构造方法后面加上一对大括号</em></strong>。同时，<strong><em>非静态代码块会在构造方法执行前被执行</em></strong>，所以我们将赋值语句放在了代码块中，于是就有了上面这段代码。若还是看不明白，没关系，看下面这段代码十有八九就明白了，我们将上面的代码换另一种方式写出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> MyList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建一个类继承自ArrayList</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span> <span class="keyword">extends</span> <span class="title">ArrayList</span></span>&#123;</span><br><span class="line">    <span class="comment">// 在类的非静态代码块中编写赋值语句</span></span><br><span class="line">    &#123;</span><br><span class="line">        add(<span class="string">"a"</span>);</span><br><span class="line">        add(<span class="string">"b"</span>);</span><br><span class="line">        add(<span class="string">"c"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;以上代码就是最开始那句代码的完整版，创建一个MyList类（名字随意），继承自ArrayList，并编写一个非静态代码块调用三次add方法，这个代码块将会在构造方法执行前被执行，因此创建一个MyList对象后，它肯定已经有三条数据了。若到此时还没有听懂，可能就需要去了解一下匿名内部类，以及代码块的执行机制了。</p><p>&ensp;&ensp;这种为集合赋值的好处就是，它可以用在任意一种集合类型上（Map，Set……），如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用此方法为map赋值</span></span><br><span class="line">HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;() &#123; </span><br><span class="line">    &#123;</span><br><span class="line">                put(<span class="string">"a"</span>, <span class="number">1</span>);</span><br><span class="line">                put(<span class="string">"b"</span>, <span class="number">2</span>); </span><br><span class="line">                put(<span class="string">"c"</span>, <span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;当然，这种方法也有一些弊端，就拿ArrayList来说，那就是这种方法得到的对象，它的类型并不是ArrayList，我们调用<strong>对象.getClass().getName()</strong>方法获取对象的类名，得到的是<strong>代码所在类的类名+$1</strong>（这里和匿名内部类的机制有关，就不详细叙述了）。所以在代码中，如果对对象的类型有着严格的要求，就需要谨慎考虑是否应该使用这种方式。</p><br><h2 id="博客总结"><a href="#博客总结" class="headerlink" title="博客总结"></a>博客总结</h2><p>&ensp;&ensp;在平常编写代码时，还是第一种方式使用的比较多，因为简单而且不容易产生问题；而第二种方，我个人建议还是少用（虽然我就是为第二种方式写的博客…..），因为在类型要求严格的程序中，可能会产生问题。当然，第二种方式真的非常机智（感叹），而且可以用在各种类型的集合上，学习一下还是很有帮助的。</p><br><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>《Java核心技术 卷Ⅰ》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题简介&quot;&gt;&lt;a href=&quot;#问题简介&quot; class=&quot;headerlink&quot; title=&quot;问题简介&quot;&gt;&lt;/a&gt;问题简介&lt;/h2&gt;&lt;p&gt;&amp;ensp;&amp;ensp;在Java当中，若希望在创建数组的同时给数组赋值很简单，可以想下面这样：&lt;/p&gt;
&lt;figure c
      
    
    </summary>
    
      <category term="JavaSE" scheme="https://tewuyiang.github.io/categories/JavaSE/"/>
    
    
      <category term="JavaSE" scheme="https://tewuyiang.github.io/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>继承内部类时使用外部类对象.super()调用内部类的构造方法</title>
    <link href="https://tewuyiang.github.io/%E5%A4%96%E9%83%A8%E7%B1%BB%E5%AF%B9%E8%B1%A1.super()%E8%B0%83%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/"/>
    <id>https://tewuyiang.github.io/外部类对象.super()调用内部类的构造方法/</id>
    <published>2019-10-09T15:05:34.000Z</published>
    <updated>2019-10-10T05:23:31.148Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题简介"><a href="#问题简介" class="headerlink" title="问题简介"></a>问题简介</h2><p>&ensp;&ensp;<font size="4">今天在看《Java编程思想》的时候，看到了一个很特殊的语法，懵逼了半天——一个派生类继承自一个内部类，想要创建这个派生类的对象，首先得创建其父类的对象，也就是这个内部类，而调用内部类的构造方法创建其对象的语法，是<strong><em>外部类对象.super();</em></strong></font></p><br><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>&ensp;&ensp;<font size="4">我们都知道，在Java当中，当我们创建一个类的对象时，在构造方法的第一行会默认的调用父类的构造方法，创建一个父类的对象，并用super关键字引用父类的对象。所以若一个类，它继承了一个内部类，那我们创建这个类的对象前，当然也必须创建一个其父类的对象，也就是这个内部类的对象。</font></p><p>&ensp;&ensp;<font size="4">但是，麻烦的是，对于内部类来说，有一个规则，那就是每个内部类的对象，<strong>必定要绑定一个其外部类的对象</strong>，这就是在内部类中，能够调用外部类方法和操作外部类属性的原因。在我们平时创建内部类对象的时候，首先需要创建一个外部类对象，在使用 <strong>外部类对象.new 内部类()</strong> 语法来创建内部类对象，这时候内部类对象绑定的就是创建它的外部类对象。</font></p><p>&ensp;&ensp;<font size="4">所以，当我们有一个类，它继承自一个内部类的时，我们要创建它的对象，需要满足两个条件：</font></p><ol><li><strong>在创建对象前，要先创建好它的父类对象，也就是它继承的内部类对象；</strong></li><li><strong>想要创建内部类对象，你得先有这个内部类的外部类对象，以供他绑定；</strong></li></ol><p>&ensp;&ensp;<font size="4">于是出现了下面这种让人懵逼的代码：</font></p><br><h2 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认构造方法</span></span><br><span class="line">        Inner()&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 带参构造方法</span></span><br><span class="line">        Inner(String string)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承类内部类的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> <span class="keyword">extends</span> <span class="title">Outer</span>.<span class="title">Inner</span></span>&#123;</span><br><span class="line">    <span class="comment">// 方式1：创建一个外部类Outer的对象，用来提供创建内部类所需的条件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Outer outer2 = <span class="keyword">new</span> Outer();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式2：类的构造方法传入一个外部类的对象，用来提供创建内部类所需的条件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test01</span><span class="params">(Outer outer1)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 通过外部类对象.super()调用内部类的构造方法</span></span><br><span class="line">        outer1.<span class="keyword">super</span>(<span class="string">"调用Inner的带参数构造方法"</span>);</span><br><span class="line">        <span class="comment">//也可以通过outer2调用</span></span><br><span class="line">        <span class="comment">// outer2.super("调用Inner的带参数构造方法");</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个外部类的对象</span></span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        <span class="comment">// 创建内部类的派生类对象，传入外部类的引用</span></span><br><span class="line">        Test01 test01 = <span class="keyword">new</span> Test01(outer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h2><p>&ensp;&ensp;<font size="4">在上面的代码中我们可以看到，Test01继承了一个内部类，于是在它的构造函数中，我们需要给他提供一个外部类Outer的对象，使它在可以满足问题分析中所说的条件2。上面的代码使用了两种方式来提供外部类的对象：</font></p><ol><li><strong>将外部类对象作为构造方法的参数传递进来</strong>，也就是上面代码中的outer1；</li><li><strong>为类创建一个静态的外部类成员</strong>，也就是上面代码中的outer2；</li></ol><p>&ensp;&ensp;<font size="4">提供了外部类Outer的对象后，创建Test01的对象时，需要一同创建的父类对象（也就是Inner）就有了可以绑定的外部类对象。然而存在一个问题，平常我们创建一个子类的对象时，构造方法中第一行会自动调用父类的构造方法，不许要我们写，但是这里却不行。因为这里的父类是一个内部类，这也就意味着编译器并不知道你想用哪个外部类对象去创建这个内部类的对象，你需要自己指定内部类绑定的外部类对象。于是，就有了上面的代码：<strong>使用 <em>外部类对象.super(参数)</em> 调用内部类的构造函数</strong>，创建内部类的对象，且这个内部类对象绑定的外部类对象就是调用构造函数的内部类对象。</font></p><p>&ensp;&ensp;<font size="4">上面的代码中有两个外部类Outer的对象，使用哪个外部类对象，创建Test01对象时，一同创建的Inner对象绑定的就是哪个outer。除此之外，还有一个问题，若构造方法中有多行代码，那外部类.super语句一定得在第一行，这和创建普通类时super语句要在第一行类似。这也很好理解，<strong>因为父类的对象一定要在子类对象之前创建</strong>。</font></p><br><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&ensp;&ensp;<font size="4">总之最重要的就是记住，一个类继承了内部类时，在这个类中想要调用父类的构造方法，得使用<strong><em>外部类对象.super(参数)</em></strong>语法，且<strong>必须显示的写出来，编译器不会自己帮你加</strong>，否则将无法成功创建类的对象。</font></p><br><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><font size="4">《Java编程思想》</font></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题简介&quot;&gt;&lt;a href=&quot;#问题简介&quot; class=&quot;headerlink&quot; title=&quot;问题简介&quot;&gt;&lt;/a&gt;问题简介&lt;/h2&gt;&lt;p&gt;&amp;ensp;&amp;ensp;&lt;font size=&quot;4&quot;&gt;今天在看《Java编程思想》的时候，看到了一个很特殊的语法，懵逼了半天
      
    
    </summary>
    
      <category term="JavaSE" scheme="https://tewuyiang.github.io/categories/JavaSE/"/>
    
    
      <category term="JavaSE" scheme="https://tewuyiang.github.io/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>HttpServlet中service方法的源码分析</title>
    <link href="https://tewuyiang.github.io/HttpServlet%E4%B8%ADservice%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>https://tewuyiang.github.io/HttpServlet中service方法源码解读/</id>
    <published>2019-07-24T03:49:09.000Z</published>
    <updated>2019-10-10T05:22:32.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&ensp;&ensp;&ensp;&ensp;最近在看《Head First Servlet &amp; JSP》这本书，  对servlet有了更加深入的理解。今天就来写一篇博客，谈一谈Servlet中一个重要的方法——<strong>service方法</strong>。</p><br><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>&ensp;&ensp;&ensp;&ensp;当浏览器对servlet发起请求时，web容器会开启一个新的线程，或者是从线程池中分配一个线程，并调用servlet的service（）方法，这个方法不需要程序员编写，而是继承自父类HttpServlet（当然，servlet不一定继承HttpServlet，也可以是实现其它协议的servlet类，但是大部分情况是Http协议）；</p><p>&ensp;&ensp;&ensp;&ensp;在service（）方法中，会查看请求的类型（Get，Post……），根据请求的类型，调用servlet中对应的方法，如doGet（）、doPost（）……下面就来看看HttpServlet类中service（）方法的源码。</p><br><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String method = req.getMethod();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (method.equals(METHOD_GET)) &#123;<span class="comment">//若为Get请求</span></span><br><span class="line">            <span class="keyword">long</span> lastModified = getLastModified(req);</span><br><span class="line">            <span class="keyword">if</span> (lastModified == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// servlet doesn't support if-modified-since, no reason</span></span><br><span class="line">                <span class="comment">// to go through further expensive logic</span></span><br><span class="line">                doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class="line">                <span class="keyword">if</span> (ifModifiedSince &lt; lastModified) &#123;</span><br><span class="line">                    <span class="comment">// If the servlet mod time is later, call doGet()</span></span><br><span class="line">                    <span class="comment">// Round down to the nearest second for a proper compare</span></span><br><span class="line">                    <span class="comment">// A ifModifiedSince of -1 will always be less</span></span><br><span class="line">                    maybeSetLastModified(resp, lastModified);</span><br><span class="line">                    doGet(req, resp);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_HEAD)) &#123;</span><br><span class="line">            <span class="keyword">long</span> lastModified = getLastModified(req);</span><br><span class="line">            maybeSetLastModified(resp, lastModified);</span><br><span class="line">            doHead(req, resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_POST)) &#123;</span><br><span class="line">            doPost(req, resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_PUT)) &#123;</span><br><span class="line">            doPut(req, resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_DELETE)) &#123;</span><br><span class="line">            doDelete(req, resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class="line">            doOptions(req,resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_TRACE)) &#123;</span><br><span class="line">            doTrace(req,resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Note that this means NO servlet supports whatever</span></span><br><span class="line">            <span class="comment">// method was requested, anywhere on this server.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            String errMsg = lStrings.getString(<span class="string">"http.method_not_implemented"</span>);</span><br><span class="line">            Object[] errArgs = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">            errArgs[<span class="number">0</span>] = method;</span><br><span class="line">            errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line"></span><br><span class="line">            resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><h3 id="对于Get类型的请求"><a href="#对于Get类型的请求" class="headerlink" title="对于Get类型的请求"></a>对于Get类型的请求</h3><p>&ensp;&ensp;&ensp;&ensp;在上面的源代码中，若请求是Get类型的，那service（）方法首先调用了<strong>getLastModified（）</strong>方法，获取了一个值赋给lastModified变量，这个东西是什么呢？</p><p>&ensp;&ensp;&ensp;&ensp;首先要知道一个东西，叫做<strong>If-Modified-Since</strong>（源码的注释中也有提到），这是Http请求的一个请求头标签，记录的是你现在请求的文件，在上一次你请求的时候，服务器上最后修改它的时间。所以，前提是你之前已经请求过这个文件，浏览器中存有这个页面的缓存，才有这个值。而源码中的<strong>getLastModified（）</strong>方法，就是用来获取这个值的。</p><p>&ensp;&ensp;&ensp;&ensp;对于第一次请求的文件，浏览器请求中是没有<strong>If-Modified-Since</strong>的，所以在上面的源码中，若是第一次请求，<strong>getLastModified（）</strong>返回的是-1，表示是第一次请求，则直接调用doGet方法，获取服务器中的文件，而这时在浏览器中，也获得了请求的文件在服务器中最后被修改的时间；</p><p>&ensp;&ensp;&ensp;&ensp;而对于不是第一次的请求，浏览器会将<strong>If-Modified-Since</strong>通过请求发送到服务器，service（）方法调用<strong>getLastModified（）</strong>方法获取到了发送来的这个值；然后它要判断一件事，那就是在你上次请求到这次请求之间，这个文件在服务器上是否被修改了，若被修改，则调用doGet（），重新获取一次，若没有被修改，则直接使用你浏览器中这个文件的缓存。</p><p>&ensp;&ensp;&ensp;&ensp;那service方法是怎么做到这个操作的呢。看上面的源代码，若<strong>getLastModified（）</strong>方法获取到的值不是-1，则表示你之前请求过这个页面，并在浏览器中有缓存。然后，service（）方法调用<strong><em>req.getDateHeader(HEADER_IFMODSINCE)</em></strong>，获取服务器上，你请求文件的最后修改时间，并与你传来的最后修改时间进行比较（两者都是long类型，表示时间的毫秒值），若<strong>服务器上的最后修改时间 &gt; 你传来的最后修改时间</strong>，则表示在你上次请求之后，这个文件被修改过，所以不能直接使用缓存，于是service（）方法调用doGet（）方法重新获取此文件，而浏览器的缓存以及<strong>If-Modified-Since</strong>也将得到更新；若<strong>服务器上的最后修改时间 == 你传来的最后修改时间</strong>，表示这个文件没有被修改，service（）方法调用<strong><em>resp.setStatus()</em></strong>方法    ，为响应设置状态码304（HttpServletResponse.SC_NOT_MODIFIED == 304），告诉浏览器可以直接使用缓存。</p><h3 id="对于Post类型的请求"><a href="#对于Post类型的请求" class="headerlink" title="对于Post类型的请求"></a>对于Post类型的请求</h3><p>&ensp;&ensp;&ensp;&ensp;对于Post类型的请求，service（）方法都是直接调用doPost（）方法，因为Post请求在标准中被规定用来对服务器中的内容进行修改，所以没有必要考虑缓存（个人理解）。当然，还有其它6种请求，但是基本上不用，我也不是很懂，这里就不说了。</p><br><h2 id="源码下载地址"><a href="#源码下载地址" class="headerlink" title="源码下载地址"></a>源码下载地址</h2><p><a href="http://www.java2s.com/Code/JarDownload/javax.servlet/javax.servlet-api-3.0.1-sources.jar.zip" target="_blank" rel="noopener">http://www.java2s.com/Code/JarDownload/javax.servlet/javax.servlet-api-3.0.1-sources.jar.zip</a></p><br><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.cnblogs.com/moxiaotao/p/9670109.html" target="_blank" rel="noopener">https://www.cnblogs.com/moxiaotao/p/9670109.html</a></p><p><a href="https://www.2cto.com/kf/201705/638441.html" target="_blank" rel="noopener">https://www.2cto.com/kf/201705/638441.html</a></p><p>《Head First Servlet &amp; JSP》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;最近在看《Head First Servlet &amp;amp; JSP》这本书，  对servl
      
    
    </summary>
    
      <category term="JavaWeb" scheme="https://tewuyiang.github.io/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="https://tewuyiang.github.io/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>根据先序遍历和中序遍历建立二叉树</title>
    <link href="https://tewuyiang.github.io/%E6%A0%B9%E6%8D%AE%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BB%BA%E7%AB%8B%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://tewuyiang.github.io/根据先序遍历和中序遍历建立二叉树/</id>
    <published>2019-07-23T14:37:34.000Z</published>
    <updated>2019-10-10T05:23:50.161Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>​    已知一棵二叉树的先序遍历以及中序遍历，重建二叉树。二叉树的每一个节点有三个属性，左子节点，右子节点，以及节点值。   </p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先序遍历服从规则<strong>“根左右”</strong>，所以由此可知，对于一个先序遍历得到的数组，第一个元素一定是<strong>根节点</strong>；</p><p>中序遍历服从规则<strong>”左根右“</strong>，所以由此可知，对于一个中序遍历得到的数组，根节点左边的元素都属于根节点的<strong>左子树</strong>，而根节点右边的元素都属于根节点的<strong>右子树</strong>；</p><p>所以，我们可以先通过先序遍历的第一个元素确定根节点，然后通过中序遍历结合根节点，获得当前根节点的左右子树，再将子树看成一棵独立的树，继续使用先序遍历判断根节点，中序遍历判断子树的方式，最终建立起整棵树；</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>假设有一棵二叉树，先序遍历为<strong>{1,2,4,7,3,5,6,8}</strong>，中序遍历为<strong>{4,7,2,1,5,3,8,6}</strong>，则建树过程如下：</p><blockquote><p>首先，通过先序遍历可知树的根节点为<strong><em>1</em></strong>，则在中序遍历中，1左边的元素<strong><em>4，7，2</em></strong>即为根的左子树的元素，而<strong><em>1</em></strong>右边的元素<strong><em>5，3，8，6</em></strong>即为根节点的右子树；</p><blockquote><p>对于左子树<strong><em>4，7，2</em></strong>来说，在先序遍历中，这三个点的顺序为<strong><em>2，4，7</em></strong>，则<strong><em>2</em></strong>为根节点，而在中序遍历中，<strong><em>4，7</em></strong>均在<strong><em>2</em></strong>的左边，则<strong><em>4，7</em></strong>均为以<strong><em>2</em></strong>为根树的左子树，且没有右子树；</p><blockquote><p>对于<strong><em>4，7</em></strong>这两个节点来说，先序遍历中，<strong><em>4</em></strong>节点在7节点之前，所以<strong><em>4</em></strong>为根节点，而<strong><em>7</em></strong>作为子树，在中序遍历中，<strong><em>7</em></strong>在<strong><em>4</em></strong>之后，所以<strong><em>7</em></strong>为右子树；</p></blockquote></blockquote><blockquote><p>对于根节点<strong><em>1</em></strong>的右子树<strong><em>5，3，8，6</em></strong>来说，在先序遍历中，<strong><em>3</em></strong>在最前面，所以<strong><em>3</em></strong>为这棵子树的根节点，而在中序遍历中，<strong><em>5</em></strong>在<strong><em>3</em></strong>的左边，所以属于左子树，而<strong><em>8，6</em></strong>在<strong><em>3</em></strong>的右边，属于右子树；</p><blockquote><p>对于根节点<strong><em>3</em></strong>的右子树<strong><em>8，6</em></strong>，在先序遍历中，<strong><em>6</em></strong>在<strong><em>8</em></strong>之前，所以，<strong><em>6</em></strong>又为根节点，而在中序遍历中，<strong><em>8</em></strong>在<strong><em>6</em></strong>的左边，所以<strong><em>8</em></strong>是<strong><em>6</em></strong>的左子节点；</p></blockquote></blockquote></blockquote><p>至此，二叉树便重建完成；</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h4 id="树的节点"><a href="#树的节点" class="headerlink" title="树的节点"></a>树的节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> val;<span class="comment">//当前节点的值</span></span><br><span class="line">TreeNode left;<span class="comment">//左子节点</span></span><br><span class="line">TreeNode right;<span class="comment">//右子节点</span></span><br><span class="line"></span><br><span class="line">TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">val = x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="建树方法"><a href="#建树方法" class="headerlink" title="建树方法"></a>建树方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* pre：线序遍历得到的数组</span></span><br><span class="line"><span class="comment">* in：中序遍历得到的数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> root = pre[<span class="number">0</span>];</span><br><span class="line">    TreeNode node = <span class="keyword">new</span> TreeNode(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找根节点在in中的索引</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( ; i&lt;in.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i] == root) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立左子树</span></span><br><span class="line">    <span class="keyword">int</span>[] leftIn = Arrays.copyOfRange(in, <span class="number">0</span>, i);</span><br><span class="line">    <span class="keyword">int</span>[] leftPre = Arrays.copyOfRange(pre, <span class="number">1</span>, i+<span class="number">1</span>);</span><br><span class="line">    node.left = reConstructBinaryTree(leftPre, leftIn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立右子树</span></span><br><span class="line">    <span class="keyword">int</span>[] rightIn = Arrays.copyOfRange(in, i+<span class="number">1</span>, in.length);</span><br><span class="line">    <span class="keyword">int</span>[] rightPre = Arrays.copyOfRange(pre, i+<span class="number">1</span>, pre.length);</span><br><span class="line">    node.right = reConstructBinaryTree(rightPre, rightIn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="建树代码（优化）"><a href="#建树代码（优化）" class="headerlink" title="建树代码（优化）"></a>建树代码（优化）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRootTreeNode(pre, <span class="number">0</span>, pre.length-<span class="number">1</span>, in, <span class="number">0</span>, in.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* preL：当前子树在先序遍历的数组中的起始下标</span></span><br><span class="line"><span class="comment">* preR：当前子树在先序遍历的数组中的结束下标</span></span><br><span class="line"><span class="comment">* inL：当前子树在中序遍历的数组中的起始下标</span></span><br><span class="line"><span class="comment">* inR：当前子树在中序遍历的数组中的起始下标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">getRootTreeNode</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> preL, </span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> preR, <span class="keyword">int</span>[] in, <span class="keyword">int</span> inL, <span class="keyword">int</span> inR)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preL &gt; preR) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode node = <span class="keyword">new</span> TreeNode(pre[preL]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=inL; i&lt;=inR; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i] == pre[preL]) &#123;</span><br><span class="line"></span><br><span class="line">            node.left = getRootTreeNode(pre, preL+<span class="number">1</span>, preL+i-inL, in, inL, i-<span class="number">1</span>);</span><br><span class="line">            node.right = getRootTreeNode(pre, preL+i-inL+<span class="number">1</span>, preR, in, i+<span class="number">1</span>, inR);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;​    已知一棵二叉树的先序遍历以及中序遍历，重建二叉树。二叉树的每一个节点有三个属性，左子节点，右子节点，以及节点值。   &lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://tewuyiang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://tewuyiang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://tewuyiang.github.io/hello-world/"/>
    <id>https://tewuyiang.github.io/hello-world/</id>
    <published>2019-07-20T13:16:12.966Z</published>
    <updated>2019-07-20T13:16:12.967Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
