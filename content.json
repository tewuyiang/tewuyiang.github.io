{"meta":{"title":"博客主页","subtitle":null,"description":"一个未来程序员的博客~~~","author":"特务依昂","url":"https://tewuyiang.github.io","root":"/"},"pages":[{"title":"tags","date":"2019-07-20T14:37:51.000Z","updated":"2019-07-20T14:42:50.692Z","comments":false,"path":"tags/index.html","permalink":"https://tewuyiang.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-07-20T14:43:46.000Z","updated":"2019-07-20T14:44:07.624Z","comments":false,"path":"categories/index.html","permalink":"https://tewuyiang.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Java实现堆排序","slug":"Java实现堆排序","date":"2019-12-26T10:26:51.000Z","updated":"2019-12-26T14:15:58.568Z","comments":true,"path":"Java实现堆排序/","link":"","permalink":"https://tewuyiang.github.io/Java实现堆排序/","excerpt":"","text":"背景&emsp;过完年就要春招了，数据结构和算法是面试中的重要内容，尤其是数据结构。趁着最近已经基本没课，时间比较多，学习一些比较常见的算法。今天刚学会堆排序，写篇博客记录一下。 描述什么是堆？&emsp;&emsp;学习堆排序，那我们首先得知道，什么是堆。堆其实就是一棵完全二叉树，分为两种： 大根堆：每个根节点的值都比它左右节点的值要大； 小根堆：每个根节点的值都比它左右节点的值要小； &emsp;&emsp;若用数组存储一个完全二叉树，那根节点的索引与左右子节点的索引满足以下条件： 左子节点索引 = 根节点索引 × 2 + 1； 右子节点索引 = 根节点索引 × 2 + 2； 如何建立堆&emsp;&emsp;以大根堆为例，我们知道，在大根堆中，每一个根节点的值，都大于它左右节点的值，而建堆的过程，其实就是调整这棵完全二叉树中节点的位置。我们从最后一个根节点开始，调整节点的位置，若当前根节点的值小于其子节点的值，则将值最大的子节点与根节点交换，交换过程实际上就是交换数组中的两个位置的值，通过上面说的根节点与子节点索引的关系；此过程结束，继续上一个根节点，重复此过程，直到整个堆的根节点置换完毕，则堆建立完毕。 &emsp;&emsp;假设堆中一共有n个节点，那最后一个根节点的下标就是n/2-1，因为在完全二叉树中，共有n/2个子节点。所以我们可以知道，在存储的数组中，0 ~ n/2-1都是非叶子节点，后面的都是叶子节点，所以建堆就是从n/2-1到0这些非叶子结点以此进行。 如何进行堆排序&emsp;&emsp;我们建立好大根堆后，堆顶元素就是所有数中最大的了，此时我们将堆顶与数组中的最后一位置交换，然后再将1 ~ n-1个元素建立成大根堆，并将堆顶与数组中第n-1个位置交换，以此类推，每次都能得到剩余值中最大的值，放到最后。进行n-1次，则就得到了一个有序的数组了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import java.util.Arrays;/** * Java实现堆排序 */@SuppressWarnings(\"all\")public class HeapSort &#123; public static void main(String[] args) &#123; int[] a = &#123;4,1,2,5,3,8,6&#125;; heapSort(a); System.out.println(Arrays.toString(a)); &#125; /** * 堆排序 * @param arr * @return */ public static int[] heapSort(int[] arr) &#123; int len = arr.length; // 建立初始大根堆 buildMaxHeap(arr, len); // 依次将堆顶的最大值放到数组的最后，并重新建堆 for (int i = len - 1; i &gt; 0; --i) &#123; swap(arr, 0, i); len--; heapity(arr, 0, len); &#125; return arr; &#125; /** * 建立初始大根堆 * @param arr * @param len */ private static void buildMaxHeap(int[] arr, int len) &#123; // 遍历所有非叶子节点，进行建堆操作 // 在完全二叉树中，共n个节点，则0 ~ (n/2)-1为非叶子节点 for (int i = len / 2 - 1; i &gt;= 0; --i) &#123; heapity(arr, i, len); &#125; &#125; /** * 建立大根堆的过程中，调整节点位置 * @param arr 表示完全二叉树的数组 * @param root 当前的根节点 * @param len 数组中，堆的长度 */ private static void heapity(int[] arr, int root, int len) &#123; // 计算左右节点的在数组中的位置 int left = (root &lt;&lt; 1) + 1; int right = (root &lt;&lt; 1) + 2; // 初始化当前子树的最大值的位置为根节点的位置 int max = root; // 判断左节点是否越界，若没有越界，则判断左节点是否大于根节点 // 若大于，则将max记录为左节点的下标 if (left &lt; len &amp;&amp; arr[left] &gt; arr[max]) &#123; max = left; &#125; // 判断右节点是否越界，若没有越界，再判断右节点的值是否大于max节点的值 // 若大于，则更新，max的值为右节点下标 if (right &lt; len &amp;&amp; arr[right] &gt; arr[max]) &#123; max = right; &#125; // 判断当前的最大值节点是否为根节点，若不是，则将最大值节点与根节点交换 if (root != max) &#123; swap(arr, root, max); // 递归交换子树的节点 heapity(arr, max, len); &#125; &#125; /** * 交换数组中两个位置的值 * @param arr * @param l * @param r */ private static void swap(int[] arr, int l, int r) &#123; int temp = arr[l]; arr[l] = arr[r]; arr[r] = temp; &#125;&#125; 参考博客https://www.cnblogs.com/lanhaicode/p/10546257.html https://www.cnblogs.com/Java3y/p/8639937.html https://www.jianshu.com/p/0d383d294a80","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tewuyiang.github.io/categories/数据结构与算法/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tewuyiang.github.io/tags/数据结构与算法/"}]},{"title":"高效算法求解数独","slug":"高效算法求解数独","date":"2019-12-26T09:55:16.000Z","updated":"2019-12-26T10:26:04.313Z","comments":true,"path":"高效算法求解数独/","link":"","permalink":"https://tewuyiang.github.io/高效算法求解数独/","excerpt":"","text":"背景&emsp;&emsp;之前上python课的时候，有一次实验是求解数独，要求时间复杂度要低；为此老师讲解了一个高效的数独算法，我觉得算法挺有意思的，写篇博客记录一下。 描述首先需要知晓数独的两个规则： 若某个位置的值已经确定，那么，和这个位置在同一行，同一列，同一个3×3的格子，都不能填写这个值，比如，九宫格（1，1）位置的值为2，那么，第一行，第一列，以及第一个3×3的格子里，都不能在填2了； 若某一行，或者某一列，或者某一个3×3里面，只有一个位置可能填1（假如是1），那么1一定是填写在这个位置，因为没有其他位置可以填它了；、 求解步骤 创建一个三维数组，假设就叫“可能值数组”，记录数独9×9的81个位置中，每个位置可能填写的值，初始情况下，每个位置的可能值都是1到9，表示每个位置都可能填写1-9中任何一个数字； 遍历数独的每一个位置，若某个位置已经有值，则将这个位置的可能值更新为这个值，比如，九宫格上，（1，1）的值已经确定是2了，那就将三维数组中（1，1）位置的可能值从[1-9]更新为[2]，直到所有的位置更新完毕； 使用上述规则1进行剪枝： （1）：从第一个位置开始遍历九宫格，若当前遍历到的位置（i,j），它的值已经知晓，那么就更新可能值数组，将第i行，第j列，以及其对应的3×3（【i/3×3 , j/3×3】就是这个3×3的第一个点）的所有位置，它们的可能值都要去除（i，j）位置的值； （2）：若某个位置在经过上一步的剪枝后，可能值只剩下一个了，那这个位置的值就确定了，比如说，位置（1，1）的初始可能值是1到9，经过上面的一步步去除，只剩下一个3了，那这个（1，1）位置填写的值必定就是3了。此时我们可以再次使用规则1，即第一行，第一列，以及其对应的3×3中，所有的格子的可能值不能有3； （3）：依次遍历每一个位置，使用上面的规则1，直到最后一格子，第一次剪枝便完成了； 使用上面的规则2进行剪枝： （1）：统计每一行，每一列，以及每一个3×3中，每个数出现的次数，比如统计第一行每个格子的可能值，看1-9各出现几次，若某个可能值只出现一次，那出现这个值的位置，就是填写这个值，比如说，在第一行，3这个数字，只有（1，1）这个位置可能填写，那（1，1）就是填3，因为其他位置的可能值当中都不包含3，也就是都不能填写3； （2）：根据上一步确定了某个位置的值后，那我们此时又可以使用规则1了，比如，上一步确定了（1，1）是填写3，那么第一行，第一列，以及第一个3×3中其余的格子， 都不能在写3了，我们从可能值数组中，将这些位置的可能，值删除3这个数； （3）：而此时，又可能出现上面的第3步中的（3）的情况； 规则2剪枝完毕后，数独还没有解决完毕，那我们只能通过枚举每一个位置的值，来一一尝试，直到找到最后的解决办法： （1）：我们在最开始创建了一个三维数组，存储每一个位置的可能值，初始情况下，每个位置的可能值都是1-9，但是经过上面两个规则的剪枝后，已经去除了很多； （2）：此时我们使用DFS深度优先搜索，尝试为每一个位置填值。经过上面的剪枝，每个位置的可能值的数量应该不一样了，而为了减少DFS搜索的次数，我们应该从可能值最少的位置开始搜索； （3）：遍历9宫格，找出还未填写值，且可能值最少的那个位置（可能有多个，找出第一个），尝试将他的第一个可能值填写在这个位置，然后再次调用规则1和规则2进行剪枝，剪枝完毕后，判断当前的九宫格中，是否有不和规则的地址，比如同一行出现两个一样的数。若没有不合法的地方，则再次进行一次（3），若有，表示这个位置不能填这个值，则从这个位置的可能值中再选择另外一个； （4）：一直使用步骤（3），直到所有的位置都确定，则表示成功解出数独，若有某个位置，它的任何一个可能值填上去，都不能得到最终结果，那数独就是无解的； 经过上面这些步骤，就能快速的解出数独，因为主要通过规则1，2进行剪枝，大大减少了枚举的次数，提升了效率； 所需计算 已知位置（i，j），则这个位置所在的3*3，其第一个点是（i/3×3 , j/3×3），i/3×3表示先作除法，去除了小数部分，再乘3，就是3的倍数了； 已知位置（i，j），如何计算这个位置属于第几个3×3，那就是（i/3×3 + j/3），每个3*3都占3行，且3列，i/3得到这个位置在第几个3行，j/3得到这个位置在第几个3列，每三行有三个3×3，所以i/3×3 + j/3就可以得到这个位置在第几个3×3； 代码因为是为了完成python实验，所以代码是用python写的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252# 此类用来表示搜索时，需要搜索的一个位置# x，y为此位置的坐标，size为此位置的可能值的数量class Node: def __init__(self, x, y, size): self.x = x self.y = y self.size = size# 读取方式2，读取top95def read_way2(): # 从文件中读取初始数独 value = [[0] * 10 for i in range(10)] # 读取文件2，3 s = infile.readline(); if s == '': return for i in range(9): for j in range(9): value[i][j] = int(s[i * 9 + j]) return value# 初始化函数def init(): value = read_way2() # 读取top95 # 初始化possibleValue，若当前位置有值，则其可能值就是这个值本身 # 若没有值,则初始的可能值就是1-9 possibleValue = [[[] for j in range(10)] for i in range(10)] for i in range(9): for j in range(9): if value[i][j] != 0: possibleValue[i][j] = [value[i][j]] else: possibleValue[i][j] = [1, 2, 3, 4, 5, 6, 7, 8, 9] return possibleValue###################################################################################################################### 根据规则1进行剪枝# 遍历所有的位置,找到已经确定的位置进行剪枝def pruningByRule1(possibleValue): for i in range(9): for j in range(9): if len(possibleValue[i][j]) == 1: removeValueByRule1(i, j, possibleValue) # 以当前位置为起点,移除重复的可能值# 在规则1剪枝中,将同一区域中,已经确定的数移除# 以(i,j)位置为起点,移除重复的可能值def removeValueByRule1(i, j, possibleValue): # 与当前值在同一行或同一列的位置，可能值减去当前位置的值 for k in range(9): # 从第i行中的可能值列表中,移除当前值 confirmOneValueInRule1(i, k, possibleValue[i][j][0], possibleValue) # 从第i列中的可能值列表中,移除当前值 confirmOneValueInRule1(k, j, possibleValue[i][j][0], possibleValue) # 与当前值在同3*3的位置，可能值减去当前位置的值 for k in range(int(i / 3) * 3, int(i / 3) * 3 + 3): for l in range(int(j / 3) * 3, int(j / 3)* 3 + 3): confirmOneValueInRule1(k, l, possibleValue[i][j][0], possibleValue)# 移除某个位置的可能值,并在移除后判断能否得到确定值def confirmOneValueInRule1(i, j, num, possibleValue): if len(possibleValue[i][j]) == 1: return # 从当前位置的可能值中,移除已经确定的数 if num in possibleValue[i][j]: possibleValue[i][j].remove(num) # 判断移除后,当前位置能否确定 if len(possibleValue[i][j]) == 1: # 若当前位置确定，则以当前位置为基准进行移除操作 removeValueByRule1(i, j, possibleValue)############################################################################################ 根据规则2剪枝,判断同一个区域每个值可能出现的次数# 若某个值可能出现的位置只有一个,表示这个值就在此位置def pruningByRule2(possibleValue): # 统计第i行，数字j可能值出现了几次 countX = [[0] * 10 for i in range(12)] # 统计第i列，数字j可能值出现了几次 countY = [[0] * 10 for i in range(12)] # 统计第i个3*3，数字j可能值出现了几次 countZ = [[0] * 10 for i in range(12)] # 统计各个区域可能值出现的次数 for i in range(9): for j in range(9): for num in possibleValue[i][j]: countX[i][num] += 1 countY[j][num] += 1 countZ[i // 3 * 3 + j // 3][num] += 1 # 判断哪些数字只出现了一次, 若只出现了一次的数字 # 表示这个数字就是那个位置的答案 for i in range(9): for j in range(1,10): # 若第i行数字j只出现了一次 if countX[i][j] == 1: for k in range(9): # 遍历第i行的每一列，判断这个唯一值出现在哪 confirmValueInRule2(i, k, j, possibleValue) # 若第i列数字j只出现了一次 if countY[i][j] == 1: for k in range(9): # 遍历第i列的每一列，判断这个唯一值出现在哪 confirmValueInRule2(k, i, j, possibleValue) # 若第i个3 * 3中，数字j的可能值只有一个 if countZ[i][j] == 1: # 遍历第i个3*3的所有位置，判断这个唯一值出现在哪 for k in range(i//3*3, i//3*3+3): for l in range(i%3*3, i%3*3+3): confirmValueInRule2(k, l, j, possibleValue)# 判断当前位置是否包含某个数,包含则为此位置的答案def confirmValueInRule2(i, j, singleNum, possibleValue): # 若当前位置已经确定值了, 直接返回 if len(possibleValue[i][j]) ==1: return # 若当前位置包含唯一可能值，则这个位置的确定值就是它 if singleNum in possibleValue[i][j]: possibleValue[i][j] = [singleNum] # 重新调用规则1 removeValueByRule1(i, j, possibleValue)############################################################################################ 递归搜索def searchForPruning(node, possibleValue): # 若没有需要填值的点了，表示搜索结束，答案已出 if node is None: return possibleValue # 获取当前位置的x，y坐标 x = node[0] y = node[1] for num in possibleValue[x][y]: # 复制一份当前状态 tempPossibleValue = copy.deepcopy(possibleValue) # 更新数据 tempPossibleValue[x][y] = [num] # 调用规则1，2 removeValueByRule1(x, y, tempPossibleValue) pruningByRule2(tempPossibleValue) # 调用规则1，2后，判断当前结果是否合法，若合法，则进行递归下一层 if judge_result(tempPossibleValue): # 递归求解 tempPossibleValue = searchForPruning(get_lowest_node(tempPossibleValue), tempPossibleValue) # 判断递归结果，若结果有返回值，则表示求解成功 if tempPossibleValue is not None: return tempPossibleValue# 获取当前可能值最小的位置def get_lowest_node(possibleValue): minn = 100 node = None for i in range(9): for j in range(9): # 若当前位置没有确定值，并且可能值的数量更少，则更新记录， if 1 &lt; len(possibleValue[i][j]) &lt; minn: minn = len(possibleValue[i][j]) node = (i, j) return node# 判断某个位置是否可以放某个值def judge_result(possibleValue): # 标记某个数字是否出现 countX = [[False] * 10 for i in range(12)] countY = [[False] * 10 for i in range(12)] countZ = [[False] * 10 for i in range(12)] # 统计各个区域可能值出现的次数 for i in range(9): for j in range(9): if len(possibleValue[i][j]) == 1: # 若当前状态不合法，返回false if countX[i][possibleValue[i][j][0]] or countY[j][possibleValue[i][j][0]] or countZ[i // 3 * 3 + j // 3][possibleValue[i][j][0]]: return False # 若合法，则标记已经确定的数字 countX[i][possibleValue[i][j][0]] = True countY[j][possibleValue[i][j][0]] = True countZ[i // 3 * 3 + j // 3][possibleValue[i][j][0]] = True return True# 判断某个位置是否可以放某个值def judge_now_number(possibleValue, i, j, num): # 判断num在这一行和这一列是否被使用 for k in range(9): if len(possibleValue[i][k]) == 1 and possibleValue[i][k][0] == num: return False if len(possibleValue[k][j]) == 1 and possibleValue[k][j][0] == num: return False # 判断num在这个3*3是否被使用 for k in range(int(i / 3) * 3, int(i / 3) * 3 + 3): for l in range(int(j / 3) * 3, int(j / 3) * 3 + 3): if len(possibleValue[k][l]) == 1 and possibleValue[k][l][0] == num: return False return True############################################################################################ 输出展示可能值列表def display(possibleValue): for i in range(9): for j in range(9): print(possibleValue[i][j], end=\"---\") print() print()############################################################################################ 主函数def main(): start = time.time() c = 0 # 主逻辑 while True: # 调用初始化函数 possibleValue = init() # 调用规则1剪枝 pruningByRule1(possibleValue) # 调用规则2剪枝 pruningByRule2(possibleValue) # display(possibleValue) possibleValue = searchForPruning(get_lowest_node(possibleValue), possibleValue) # 判断是否有解 if possibleValue is not None: display(possibleValue) else: print(\"无解\") if not judge_result(possibleValue): print(\"结果异常\") c += 1 if c &gt;= 90: break end = time.time() print(end - start)# 读取本地存储文件infile = open(\"D:/top95.txt\")main() 扩展&emsp;&emsp;数独求解的算法，上面这种并不是最快的，还有一种叫做舞蹈链（Dancing Links）的算法，效率更高，有兴趣的可以了解一下；","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tewuyiang.github.io/categories/数据结构与算法/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tewuyiang.github.io/tags/数据结构与算法/"}]},{"title":"Java创建List、Map等集合对象的同时进行赋值操作","slug":"Java创建List对象同时进行赋值操作","date":"2019-11-28T15:25:47.000Z","updated":"2019-11-29T15:28:14.609Z","comments":true,"path":"Java创建List对象同时进行赋值操作/","link":"","permalink":"https://tewuyiang.github.io/Java创建List对象同时进行赋值操作/","excerpt":"","text":"问题简介&ensp;&ensp;在Java当中，若希望在创建数组的同时给数组赋值很简单，可以想下面这样： 12int[] num = &#123;1,2,3&#125;;String strs = &#123;\"a\", \"b\", \"c\"&#125; &ensp;&ensp;但是，如果我们创建List集合，或者Map集合时，也想快速地为它赋初始值，应当如何做呢？ 解决方式方式1：调用函数&ensp;&ensp;请看如下代码： 1ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(\"aa\", \"bb\", \"cc\")); &ensp;&ensp;Arrays.asList(T… a) 方法的参数是一个可变长参数，也就是说他能够传入一个数组，也能够传入多个参数，而它的作用就是将传入的数组或多个数据封装成List集合返回，而上面的代码就是接收返回的List集合，并将其作为参数传入ArrayList的构造方法，创建一个新的ArrayList对象。 &ensp;&ensp;说到这里有人可能要问了，为什么不能直接将asList方法的返回值赋给list参数，而要将它传入构造器创建新的对象呢？这不是脱裤子放屁——多此一举吗。当然不是，请看下面的代码： 12345678// 代码1List&lt;String&gt; list1 = Arrays.asList(\"aa\", \"bb\", \"cc\");list1.add(\"dd\"); // UnsupportedOperationException// 代码2String[] str = &#123;\"a\",\"b\",\"c\"&#125;;List&lt;String&gt; list = Arrays.asList(str);str[0] = \"e\"; // list中的0号位置也一同改变 &ensp;&ensp;上面有两段代码，看似没有问题，但是运行结果却和大家想象的有些不同。首先代码1，使用asList方法返回的创建的List对象，不允许进行修改操作，否则将会抛出一个UnsupportedOperationException；再来看代码2，我们将一个数组作为asList的参数，得到一个List对象，但是此时我们改变这个数组中元素的值，list对象的值也会发生改变，因为这个List对象底层引用的就是这个数组，并且和代码1一样，这个list也不能修改。 &ensp;&ensp;但是，若我们将返回的List对象作为参数传入ArrayList的构造器中，这个问题就不会发生，因为ArrayList的构造器将会把传入的list中所有的元素复制一份，因此不会影响到原数组，且可以随意改变。 方式2：匿名内部类&ensp;&ensp;这是一个非常机智的方式，就是看到了下面这行代码，我才忍不住写了这篇博客： 1List&lt;String&gt; list = new ArrayList&lt;String&gt;()&#123; &#123;add(\"a\"); add(\"b\"); add(\"c\");&#125; &#125;; &ensp;&ensp;乍一看是不是有点懵逼，我们将这段代码展开来看，就会清晰很多： 1234567List&lt;String&gt; list = new ArrayList&lt;String&gt;() &#123; &#123; add(\"a\"); add(\"b\"); add(\"c\"); &#125; &#125;; &ensp;&ensp;这下应该比之前容易理解了。这段代码就是创建了一个匿名内部类对象，且这个类继承自ArrayList，在这个匿名内部类中添加了一个非静态代码块，并在代码块中调用了三次add方法，为这个List对象赋值。 &ensp;&ensp;我们知道，若我们想创建一个对象，可以直接new 构造方法，但是我们若想写一个匿名内部类，这个匿名内部类继承自某个类，只需在构造方法后面加上一对大括号。同时，非静态代码块会在构造方法执行前被执行，所以我们将赋值语句放在了代码块中，于是就有了上面这段代码。若还是看不明白，没关系，看下面这段代码十有八九就明白了，我们将上面的代码换另一种方式写出来： 123456789101112131415public class Test &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new MyList(); &#125;&#125;// 创建一个类继承自ArrayListclass MyList extends ArrayList&#123; // 在类的非静态代码块中编写赋值语句 &#123; add(\"a\"); add(\"b\"); add(\"c\"); &#125;&#125; &ensp;&ensp;以上代码就是最开始那句代码的完整版，创建一个MyList类（名字随意），继承自ArrayList，并编写一个非静态代码块调用三次add方法，这个代码块将会在构造方法执行前被执行，因此创建一个MyList对象后，它肯定已经有三条数据了。若到此时还没有听懂，可能就需要去了解一下匿名内部类，以及代码块的执行机制了。 &ensp;&ensp;这种为集合赋值的好处就是，它可以用在任意一种集合类型上（Map，Set……），如下代码： 12345678// 使用此方法为map赋值HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;() &#123; &#123; put(\"a\", 1); put(\"b\", 2); put(\"c\", 3); &#125; &#125;; &ensp;&ensp;当然，这种方法也有一些弊端，就拿ArrayList来说，那就是这种方法得到的对象，它的类型并不是ArrayList，我们调用对象.getClass().getName()方法获取对象的类名，得到的是代码所在类的类名+$1（这里和匿名内部类的机制有关，就不详细叙述了）。所以在代码中，如果对对象的类型有着严格的要求，就需要谨慎考虑是否应该使用这种方式。 博客总结&ensp;&ensp;在平常编写代码时，还是第一种方式使用的比较多，因为简单而且不容易产生问题；而第二种方，我个人建议还是少用（虽然我就是为第二种方式写的博客…..），因为在类型要求严格的程序中，可能会产生问题。当然，第二种方式真的非常机智（感叹），而且可以用在各种类型的集合上，学习一下还是很有帮助的。 参考文献《Java核心技术 卷Ⅰ》","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://tewuyiang.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://tewuyiang.github.io/tags/JavaSE/"}]},{"title":"继承内部类时使用外部类对象.super()调用内部类的构造方法","slug":"外部类对象.super()调用内部类的构造方法","date":"2019-10-09T15:05:34.000Z","updated":"2019-10-10T05:23:31.148Z","comments":true,"path":"外部类对象.super()调用内部类的构造方法/","link":"","permalink":"https://tewuyiang.github.io/外部类对象.super()调用内部类的构造方法/","excerpt":"","text":"问题简介&ensp;&ensp;今天在看《Java编程思想》的时候，看到了一个很特殊的语法，懵逼了半天——一个派生类继承自一个内部类，想要创建这个派生类的对象，首先得创建其父类的对象，也就是这个内部类，而调用内部类的构造方法创建其对象的语法，是外部类对象.super(); 问题分析&ensp;&ensp;我们都知道，在Java当中，当我们创建一个类的对象时，在构造方法的第一行会默认的调用父类的构造方法，创建一个父类的对象，并用super关键字引用父类的对象。所以若一个类，它继承了一个内部类，那我们创建这个类的对象前，当然也必须创建一个其父类的对象，也就是这个内部类的对象。 &ensp;&ensp;但是，麻烦的是，对于内部类来说，有一个规则，那就是每个内部类的对象，必定要绑定一个其外部类的对象，这就是在内部类中，能够调用外部类方法和操作外部类属性的原因。在我们平时创建内部类对象的时候，首先需要创建一个外部类对象，在使用 外部类对象.new 内部类() 语法来创建内部类对象，这时候内部类对象绑定的就是创建它的外部类对象。 &ensp;&ensp;所以，当我们有一个类，它继承自一个内部类的时，我们要创建它的对象，需要满足两个条件： 在创建对象前，要先创建好它的父类对象，也就是它继承的内部类对象； 想要创建内部类对象，你得先有这个内部类的外部类对象，以供他绑定； &ensp;&ensp;于是出现了下面这种让人懵逼的代码： 代码案例12345678910111213141516171819202122232425262728293031323334// 外部类class Outer&#123; // 内部类 class Inner&#123; // 默认构造方法 Inner()&#123; &#125; // 带参构造方法 Inner(String string)&#123; &#125; &#125;&#125;// 继承类内部类的类public class Test01 extends Outer.Inner&#123; // 方式1：创建一个外部类Outer的对象，用来提供创建内部类所需的条件 private static Outer outer2 = new Outer(); // 方式2：类的构造方法传入一个外部类的对象，用来提供创建内部类所需的条件 public Test01(Outer outer1)&#123; // 通过外部类对象.super()调用内部类的构造方法 outer1.super(\"调用Inner的带参数构造方法\"); //也可以通过outer2调用 // outer2.super(\"调用Inner的带参数构造方法\"); &#125; public static void main(String[] args) &#123; // 创建一个外部类的对象 Outer outer = new Outer(); // 创建内部类的派生类对象，传入外部类的引用 Test01 test01 = new Test01(outer); &#125;&#125; 代码解读&ensp;&ensp;在上面的代码中我们可以看到，Test01继承了一个内部类，于是在它的构造函数中，我们需要给他提供一个外部类Outer的对象，使它在可以满足问题分析中所说的条件2。上面的代码使用了两种方式来提供外部类的对象： 将外部类对象作为构造方法的参数传递进来，也就是上面代码中的outer1； 为类创建一个静态的外部类成员，也就是上面代码中的outer2； &ensp;&ensp;提供了外部类Outer的对象后，创建Test01的对象时，需要一同创建的父类对象（也就是Inner）就有了可以绑定的外部类对象。然而存在一个问题，平常我们创建一个子类的对象时，构造方法中第一行会自动调用父类的构造方法，不许要我们写，但是这里却不行。因为这里的父类是一个内部类，这也就意味着编译器并不知道你想用哪个外部类对象去创建这个内部类的对象，你需要自己指定内部类绑定的外部类对象。于是，就有了上面的代码：使用 外部类对象.super(参数) 调用内部类的构造函数，创建内部类的对象，且这个内部类对象绑定的外部类对象就是调用构造函数的内部类对象。 &ensp;&ensp;上面的代码中有两个外部类Outer的对象，使用哪个外部类对象，创建Test01对象时，一同创建的Inner对象绑定的就是哪个outer。除此之外，还有一个问题，若构造方法中有多行代码，那外部类.super语句一定得在第一行，这和创建普通类时super语句要在第一行类似。这也很好理解，因为父类的对象一定要在子类对象之前创建。 总结&ensp;&ensp;总之最重要的就是记住，一个类继承了内部类时，在这个类中想要调用父类的构造方法，得使用外部类对象.super(参数)语法，且必须显示的写出来，编译器不会自己帮你加，否则将无法成功创建类的对象。 参考文献《Java编程思想》","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://tewuyiang.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://tewuyiang.github.io/tags/JavaSE/"}]},{"title":"HttpServlet中service方法的源码分析","slug":"HttpServlet中service方法源码解读","date":"2019-07-24T03:49:09.000Z","updated":"2019-10-10T05:22:32.939Z","comments":true,"path":"HttpServlet中service方法源码解读/","link":"","permalink":"https://tewuyiang.github.io/HttpServlet中service方法源码解读/","excerpt":"","text":"前言&ensp;&ensp;&ensp;&ensp;最近在看《Head First Servlet &amp; JSP》这本书， 对servlet有了更加深入的理解。今天就来写一篇博客，谈一谈Servlet中一个重要的方法——service方法。 介绍&ensp;&ensp;&ensp;&ensp;当浏览器对servlet发起请求时，web容器会开启一个新的线程，或者是从线程池中分配一个线程，并调用servlet的service（）方法，这个方法不需要程序员编写，而是继承自父类HttpServlet（当然，servlet不一定继承HttpServlet，也可以是实现其它协议的servlet类，但是大部分情况是Http协议）； &ensp;&ensp;&ensp;&ensp;在service（）方法中，会查看请求的类型（Get，Post……），根据请求的类型，调用servlet中对应的方法，如doGet（）、doPost（）……下面就来看看HttpServlet类中service（）方法的源码。 源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String method = req.getMethod(); if (method.equals(METHOD_GET)) &#123; //若为Get请求 long lastModified = getLastModified(req); if (lastModified == -1) &#123; // servlet doesn't support if-modified-since, no reason // to go through further expensive logic doGet(req, resp); &#125; else &#123; long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE); if (ifModifiedSince &lt; lastModified) &#123; // If the servlet mod time is later, call doGet() // Round down to the nearest second for a proper compare // A ifModifiedSince of -1 will always be less maybeSetLastModified(resp, lastModified); doGet(req, resp); &#125; else &#123; resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); &#125; &#125; &#125; else if (method.equals(METHOD_HEAD)) &#123; long lastModified = getLastModified(req); maybeSetLastModified(resp, lastModified); doHead(req, resp); &#125; else if (method.equals(METHOD_POST)) &#123; doPost(req, resp); &#125; else if (method.equals(METHOD_PUT)) &#123; doPut(req, resp); &#125; else if (method.equals(METHOD_DELETE)) &#123; doDelete(req, resp); &#125; else if (method.equals(METHOD_OPTIONS)) &#123; doOptions(req,resp); &#125; else if (method.equals(METHOD_TRACE)) &#123; doTrace(req,resp); &#125; else &#123; // // Note that this means NO servlet supports whatever // method was requested, anywhere on this server. // String errMsg = lStrings.getString(\"http.method_not_implemented\"); Object[] errArgs = new Object[1]; errArgs[0] = method; errMsg = MessageFormat.format(errMsg, errArgs); resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg); &#125; &#125; 源码解读对于Get类型的请求&ensp;&ensp;&ensp;&ensp;在上面的源代码中，若请求是Get类型的，那service（）方法首先调用了getLastModified（）方法，获取了一个值赋给lastModified变量，这个东西是什么呢？ &ensp;&ensp;&ensp;&ensp;首先要知道一个东西，叫做If-Modified-Since（源码的注释中也有提到），这是Http请求的一个请求头标签，记录的是你现在请求的文件，在上一次你请求的时候，服务器上最后修改它的时间。所以，前提是你之前已经请求过这个文件，浏览器中存有这个页面的缓存，才有这个值。而源码中的getLastModified（）方法，就是用来获取这个值的。 &ensp;&ensp;&ensp;&ensp;对于第一次请求的文件，浏览器请求中是没有If-Modified-Since的，所以在上面的源码中，若是第一次请求，getLastModified（）返回的是-1，表示是第一次请求，则直接调用doGet方法，获取服务器中的文件，而这时在浏览器中，也获得了请求的文件在服务器中最后被修改的时间； &ensp;&ensp;&ensp;&ensp;而对于不是第一次的请求，浏览器会将If-Modified-Since通过请求发送到服务器，service（）方法调用getLastModified（）方法获取到了发送来的这个值；然后它要判断一件事，那就是在你上次请求到这次请求之间，这个文件在服务器上是否被修改了，若被修改，则调用doGet（），重新获取一次，若没有被修改，则直接使用你浏览器中这个文件的缓存。 &ensp;&ensp;&ensp;&ensp;那service方法是怎么做到这个操作的呢。看上面的源代码，若getLastModified（）方法获取到的值不是-1，则表示你之前请求过这个页面，并在浏览器中有缓存。然后，service（）方法调用req.getDateHeader(HEADER_IFMODSINCE)，获取服务器上，你请求文件的最后修改时间，并与你传来的最后修改时间进行比较（两者都是long类型，表示时间的毫秒值），若服务器上的最后修改时间 &gt; 你传来的最后修改时间，则表示在你上次请求之后，这个文件被修改过，所以不能直接使用缓存，于是service（）方法调用doGet（）方法重新获取此文件，而浏览器的缓存以及If-Modified-Since也将得到更新；若服务器上的最后修改时间 == 你传来的最后修改时间，表示这个文件没有被修改，service（）方法调用resp.setStatus()方法 ，为响应设置状态码304（HttpServletResponse.SC_NOT_MODIFIED == 304），告诉浏览器可以直接使用缓存。 对于Post类型的请求&ensp;&ensp;&ensp;&ensp;对于Post类型的请求，service（）方法都是直接调用doPost（）方法，因为Post请求在标准中被规定用来对服务器中的内容进行修改，所以没有必要考虑缓存（个人理解）。当然，还有其它6种请求，但是基本上不用，我也不是很懂，这里就不说了。 源码下载地址http://www.java2s.com/Code/JarDownload/javax.servlet/javax.servlet-api-3.0.1-sources.jar.zip 参考文献https://www.cnblogs.com/moxiaotao/p/9670109.html https://www.2cto.com/kf/201705/638441.html 《Head First Servlet &amp; JSP》","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://tewuyiang.github.io/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://tewuyiang.github.io/tags/JavaWeb/"}]},{"title":"根据先序遍历和中序遍历建立二叉树","slug":"根据先序遍历和中序遍历建立二叉树","date":"2019-07-23T14:37:34.000Z","updated":"2019-10-10T05:23:50.161Z","comments":true,"path":"根据先序遍历和中序遍历建立二叉树/","link":"","permalink":"https://tewuyiang.github.io/根据先序遍历和中序遍历建立二叉树/","excerpt":"","text":"问题​ 已知一棵二叉树的先序遍历以及中序遍历，重建二叉树。二叉树的每一个节点有三个属性，左子节点，右子节点，以及节点值。 思路先序遍历服从规则“根左右”，所以由此可知，对于一个先序遍历得到的数组，第一个元素一定是根节点； 中序遍历服从规则”左根右“，所以由此可知，对于一个中序遍历得到的数组，根节点左边的元素都属于根节点的左子树，而根节点右边的元素都属于根节点的右子树； 所以，我们可以先通过先序遍历的第一个元素确定根节点，然后通过中序遍历结合根节点，获得当前根节点的左右子树，再将子树看成一棵独立的树，继续使用先序遍历判断根节点，中序遍历判断子树的方式，最终建立起整棵树； 例子假设有一棵二叉树，先序遍历为{1,2,4,7,3,5,6,8}，中序遍历为{4,7,2,1,5,3,8,6}，则建树过程如下： 首先，通过先序遍历可知树的根节点为1，则在中序遍历中，1左边的元素4，7，2即为根的左子树的元素，而1右边的元素5，3，8，6即为根节点的右子树； 对于左子树4，7，2来说，在先序遍历中，这三个点的顺序为2，4，7，则2为根节点，而在中序遍历中，4，7均在2的左边，则4，7均为以2为根树的左子树，且没有右子树； 对于4，7这两个节点来说，先序遍历中，4节点在7节点之前，所以4为根节点，而7作为子树，在中序遍历中，7在4之后，所以7为右子树； 对于根节点1的右子树5，3，8，6来说，在先序遍历中，3在最前面，所以3为这棵子树的根节点，而在中序遍历中，5在3的左边，所以属于左子树，而8，6在3的右边，属于右子树； 对于根节点3的右子树8，6，在先序遍历中，6在8之前，所以，6又为根节点，而在中序遍历中，8在6的左边，所以8是6的左子节点； 至此，二叉树便重建完成； 代码树的节点123456789public class TreeNode &#123; int val; //当前节点的值 TreeNode left; //左子节点 TreeNode right; //右子节点 TreeNode(int x) &#123; val = x; &#125;&#125; 建树方法1234567891011121314151617181920212223242526272829303132/*** pre：线序遍历得到的数组* in：中序遍历得到的数组*/public TreeNode reConstructBinaryTree(int[] pre, int[] in) &#123; if(pre.length == 0) &#123; return null; &#125; int root = pre[0]; TreeNode node = new TreeNode(root); //寻找根节点在in中的索引 int i = 0; for( ; i&lt;in.length; ++i) &#123; if(in[i] == root) &#123; break; &#125; &#125; //建立左子树 int[] leftIn = Arrays.copyOfRange(in, 0, i); int[] leftPre = Arrays.copyOfRange(pre, 1, i+1); node.left = reConstructBinaryTree(leftPre, leftIn); //建立右子树 int[] rightIn = Arrays.copyOfRange(in, i+1, in.length); int[] rightPre = Arrays.copyOfRange(pre, i+1, pre.length); node.right = reConstructBinaryTree(rightPre, rightIn); return node;&#125; 建树代码（优化）1234567891011121314151617181920212223242526272829public TreeNode reConstructBinaryTree(int[] pre, int[] in) &#123; return getRootTreeNode(pre, 0, pre.length-1, in, 0, in.length-1);&#125;/*** preL：当前子树在先序遍历的数组中的起始下标* preR：当前子树在先序遍历的数组中的结束下标* inL：当前子树在中序遍历的数组中的起始下标* inR：当前子树在中序遍历的数组中的起始下标*/public TreeNode getRootTreeNode(int[] pre, int preL, int preR, int[] in, int inL, int inR) &#123; if(preL &gt; preR) &#123; return null; &#125; TreeNode node = new TreeNode(pre[preL]); for(int i=inL; i&lt;=inR; ++i) &#123; if(in[i] == pre[preL]) &#123; node.left = getRootTreeNode(pre, preL+1, preL+i-inL, in, inL, i-1); node.right = getRootTreeNode(pre, preL+i-inL+1, preR, in, i+1, inR); break; &#125; &#125; return node;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tewuyiang.github.io/categories/数据结构与算法/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tewuyiang.github.io/tags/数据结构与算法/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-07-20T13:16:12.966Z","updated":"2019-07-20T13:16:12.967Z","comments":true,"path":"hello-world/","link":"","permalink":"https://tewuyiang.github.io/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}