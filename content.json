{"meta":{"title":"博客主页","subtitle":null,"description":"一个未来程序员的博客~~~","author":"特务依昂","url":"https://tewuyiang.github.io","root":"/"},"pages":[{"title":"tags","date":"2019-07-20T14:37:51.000Z","updated":"2019-07-20T14:42:50.692Z","comments":false,"path":"tags/index.html","permalink":"https://tewuyiang.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-07-20T14:43:46.000Z","updated":"2019-07-20T14:44:07.624Z","comments":false,"path":"categories/index.html","permalink":"https://tewuyiang.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"继承内部类时使用外部类对象.super()调用内部类的构造方法","slug":"外部类对象.super()调用内部类的构造方法","date":"2019-10-09T15:05:34.000Z","updated":"2019-10-10T05:23:31.148Z","comments":true,"path":"外部类对象.super()调用内部类的构造方法/","link":"","permalink":"https://tewuyiang.github.io/外部类对象.super()调用内部类的构造方法/","excerpt":"","text":"问题简介&ensp;&ensp;今天在看《Java编程思想》的时候，看到了一个很特殊的语法，懵逼了半天——一个派生类继承自一个内部类，想要创建这个派生类的对象，首先得创建其父类的对象，也就是这个内部类，而调用内部类的构造方法创建其对象的语法，是外部类对象.super(); 问题分析&ensp;&ensp;我们都知道，在Java当中，当我们创建一个类的对象时，在构造方法的第一行会默认的调用父类的构造方法，创建一个父类的对象，并用super关键字引用父类的对象。所以若一个类，它继承了一个内部类，那我们创建这个类的对象前，当然也必须创建一个其父类的对象，也就是这个内部类的对象。 &ensp;&ensp;但是，麻烦的是，对于内部类来说，有一个规则，那就是每个内部类的对象，必定要绑定一个其外部类的对象，这就是在内部类中，能够调用外部类方法和操作外部类属性的原因。在我们平时创建内部类对象的时候，首先需要创建一个外部类对象，在使用 外部类对象.new 内部类() 语法来创建内部类对象，这时候内部类对象绑定的就是创建它的外部类对象。 &ensp;&ensp;所以，当我们有一个类，它继承自一个内部类的时，我们要创建它的对象，需要满足两个条件： 在创建对象前，要先创建好它的父类对象，也就是它继承的内部类对象； 想要创建内部类对象，你得先有这个内部类的外部类对象，以供他绑定； &ensp;&ensp;于是出现了下面这种让人懵逼的代码： 代码案例12345678910111213141516171819202122232425262728293031323334// 外部类class Outer&#123; // 内部类 class Inner&#123; // 默认构造方法 Inner()&#123; &#125; // 带参构造方法 Inner(String string)&#123; &#125; &#125;&#125;// 继承类内部类的类public class Test01 extends Outer.Inner&#123; // 方式1：创建一个外部类Outer的对象，用来提供创建内部类所需的条件 private static Outer outer2 = new Outer(); // 方式2：类的构造方法传入一个外部类的对象，用来提供创建内部类所需的条件 public Test01(Outer outer1)&#123; // 通过外部类对象.super()调用内部类的构造方法 outer1.super(\"调用Inner的带参数构造方法\"); //也可以通过outer2调用 // outer2.super(\"调用Inner的带参数构造方法\"); &#125; public static void main(String[] args) &#123; // 创建一个外部类的对象 Outer outer = new Outer(); // 创建内部类的派生类对象，传入外部类的引用 Test01 test01 = new Test01(outer); &#125;&#125; 代码解读&ensp;&ensp;在上面的代码中我们可以看到，Test01继承了一个内部类，于是在它的构造函数中，我们需要给他提供一个外部类Outer的对象，使它在可以满足问题分析中所说的条件2。上面的代码使用了两种方式来提供外部类的对象： 将外部类对象作为构造方法的参数传递进来，也就是上面代码中的outer1； 为类创建一个静态的外部类成员，也就是上面代码中的outer2； &ensp;&ensp;提供了外部类Outer的对象后，创建Test01的对象时，需要一同创建的父类对象（也就是Inner）就有了可以绑定的外部类对象。然而存在一个问题，平常我们创建一个子类的对象时，构造方法中第一行会自动调用父类的构造方法，不许要我们写，但是这里却不行。因为这里的父类是一个内部类，这也就意味着编译器并不知道你想用哪个外部类对象去创建这个内部类的对象，你需要自己指定内部类绑定的外部类对象。于是，就有了上面的代码：使用 外部类对象.super(参数) 调用内部类的构造函数，创建内部类的对象，且这个内部类对象绑定的外部类对象就是调用构造函数的内部类对象。 &ensp;&ensp;上面的代码中有两个外部类Outer的对象，使用哪个外部类对象，创建Test01对象时，一同创建的Inner对象绑定的就是哪个outer。除此之外，还有一个问题，若构造方法中有多行代码，那外部类.super语句一定得在第一行，这和创建普通类时super语句要在第一行类似。这也很好理解，因为父类的对象一定要在子类对象之前创建。 总结&ensp;&ensp;总之最重要的就是记住，一个类继承了内部类时，在这个类中想要调用父类的构造方法，得使用外部类对象.super(参数)语法，且必须显示的写出来，编译器不会自己帮你加，否则将无法成功创建类的对象。 参考文献《Java编程思想》","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://tewuyiang.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://tewuyiang.github.io/tags/JavaSE/"}]},{"title":"HttpServlet中service方法的源码分析","slug":"HttpServlet中service方法源码解读","date":"2019-07-24T03:49:09.000Z","updated":"2019-10-10T05:22:32.939Z","comments":true,"path":"HttpServlet中service方法源码解读/","link":"","permalink":"https://tewuyiang.github.io/HttpServlet中service方法源码解读/","excerpt":"","text":"前言&ensp;&ensp;&ensp;&ensp;最近在看《Head First Servlet &amp; JSP》这本书， 对servlet有了更加深入的理解。今天就来写一篇博客，谈一谈Servlet中一个重要的方法——service方法。 介绍&ensp;&ensp;&ensp;&ensp;当浏览器对servlet发起请求时，web容器会开启一个新的线程，或者是从线程池中分配一个线程，并调用servlet的service（）方法，这个方法不需要程序员编写，而是继承自父类HttpServlet（当然，servlet不一定继承HttpServlet，也可以是实现其它协议的servlet类，但是大部分情况是Http协议）； &ensp;&ensp;&ensp;&ensp;在service（）方法中，会查看请求的类型（Get，Post……），根据请求的类型，调用servlet中对应的方法，如doGet（）、doPost（）……下面就来看看HttpServlet类中service（）方法的源码。 源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String method = req.getMethod(); if (method.equals(METHOD_GET)) &#123; //若为Get请求 long lastModified = getLastModified(req); if (lastModified == -1) &#123; // servlet doesn't support if-modified-since, no reason // to go through further expensive logic doGet(req, resp); &#125; else &#123; long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE); if (ifModifiedSince &lt; lastModified) &#123; // If the servlet mod time is later, call doGet() // Round down to the nearest second for a proper compare // A ifModifiedSince of -1 will always be less maybeSetLastModified(resp, lastModified); doGet(req, resp); &#125; else &#123; resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); &#125; &#125; &#125; else if (method.equals(METHOD_HEAD)) &#123; long lastModified = getLastModified(req); maybeSetLastModified(resp, lastModified); doHead(req, resp); &#125; else if (method.equals(METHOD_POST)) &#123; doPost(req, resp); &#125; else if (method.equals(METHOD_PUT)) &#123; doPut(req, resp); &#125; else if (method.equals(METHOD_DELETE)) &#123; doDelete(req, resp); &#125; else if (method.equals(METHOD_OPTIONS)) &#123; doOptions(req,resp); &#125; else if (method.equals(METHOD_TRACE)) &#123; doTrace(req,resp); &#125; else &#123; // // Note that this means NO servlet supports whatever // method was requested, anywhere on this server. // String errMsg = lStrings.getString(\"http.method_not_implemented\"); Object[] errArgs = new Object[1]; errArgs[0] = method; errMsg = MessageFormat.format(errMsg, errArgs); resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg); &#125; &#125; 源码解读对于Get类型的请求&ensp;&ensp;&ensp;&ensp;在上面的源代码中，若请求是Get类型的，那service（）方法首先调用了getLastModified（）方法，获取了一个值赋给lastModified变量，这个东西是什么呢？ &ensp;&ensp;&ensp;&ensp;首先要知道一个东西，叫做If-Modified-Since（源码的注释中也有提到），这是Http请求的一个请求头标签，记录的是你现在请求的文件，在上一次你请求的时候，服务器上最后修改它的时间。所以，前提是你之前已经请求过这个文件，浏览器中存有这个页面的缓存，才有这个值。而源码中的getLastModified（）方法，就是用来获取这个值的。 &ensp;&ensp;&ensp;&ensp;对于第一次请求的文件，浏览器请求中是没有If-Modified-Since的，所以在上面的源码中，若是第一次请求，getLastModified（）返回的是-1，表示是第一次请求，则直接调用doGet方法，获取服务器中的文件，而这时在浏览器中，也获得了请求的文件在服务器中最后被修改的时间； &ensp;&ensp;&ensp;&ensp;而对于不是第一次的请求，浏览器会将If-Modified-Since通过请求发送到服务器，service（）方法调用getLastModified（）方法获取到了发送来的这个值；然后它要判断一件事，那就是在你上次请求到这次请求之间，这个文件在服务器上是否被修改了，若被修改，则调用doGet（），重新获取一次，若没有被修改，则直接使用你浏览器中这个文件的缓存。 &ensp;&ensp;&ensp;&ensp;那service方法是怎么做到这个操作的呢。看上面的源代码，若getLastModified（）方法获取到的值不是-1，则表示你之前请求过这个页面，并在浏览器中有缓存。然后，service（）方法调用req.getDateHeader(HEADER_IFMODSINCE)，获取服务器上，你请求文件的最后修改时间，并与你传来的最后修改时间进行比较（两者都是long类型，表示时间的毫秒值），若服务器上的最后修改时间 &gt; 你传来的最后修改时间，则表示在你上次请求之后，这个文件被修改过，所以不能直接使用缓存，于是service（）方法调用doGet（）方法重新获取此文件，而浏览器的缓存以及If-Modified-Since也将得到更新；若服务器上的最后修改时间 == 你传来的最后修改时间，表示这个文件没有被修改，service（）方法调用resp.setStatus()方法 ，为响应设置状态码304（HttpServletResponse.SC_NOT_MODIFIED == 304），告诉浏览器可以直接使用缓存。 对于Post类型的请求&ensp;&ensp;&ensp;&ensp;对于Post类型的请求，service（）方法都是直接调用doPost（）方法，因为Post请求在标准中被规定用来对服务器中的内容进行修改，所以没有必要考虑缓存（个人理解）。当然，还有其它6种请求，但是基本上不用，我也不是很懂，这里就不说了。 源码下载地址http://www.java2s.com/Code/JarDownload/javax.servlet/javax.servlet-api-3.0.1-sources.jar.zip 参考文献https://www.cnblogs.com/moxiaotao/p/9670109.html https://www.2cto.com/kf/201705/638441.html 《Head First Servlet &amp; JSP》","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://tewuyiang.github.io/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://tewuyiang.github.io/tags/JavaWeb/"}]},{"title":"根据先序遍历和中序遍历建立二叉树","slug":"根据先序遍历和中序遍历建立二叉树","date":"2019-07-23T14:37:34.000Z","updated":"2019-10-10T05:23:50.161Z","comments":true,"path":"根据先序遍历和中序遍历建立二叉树/","link":"","permalink":"https://tewuyiang.github.io/根据先序遍历和中序遍历建立二叉树/","excerpt":"","text":"问题​ 已知一棵二叉树的先序遍历以及中序遍历，重建二叉树。二叉树的每一个节点有三个属性，左子节点，右子节点，以及节点值。 思路先序遍历服从规则“根左右”，所以由此可知，对于一个先序遍历得到的数组，第一个元素一定是根节点； 中序遍历服从规则”左根右“，所以由此可知，对于一个中序遍历得到的数组，根节点左边的元素都属于根节点的左子树，而根节点右边的元素都属于根节点的右子树； 所以，我们可以先通过先序遍历的第一个元素确定根节点，然后通过中序遍历结合根节点，获得当前根节点的左右子树，再将子树看成一棵独立的树，继续使用先序遍历判断根节点，中序遍历判断子树的方式，最终建立起整棵树； 例子假设有一棵二叉树，先序遍历为{1,2,4,7,3,5,6,8}，中序遍历为{4,7,2,1,5,3,8,6}，则建树过程如下： 首先，通过先序遍历可知树的根节点为1，则在中序遍历中，1左边的元素4，7，2即为根的左子树的元素，而1右边的元素5，3，8，6即为根节点的右子树； 对于左子树4，7，2来说，在先序遍历中，这三个点的顺序为2，4，7，则2为根节点，而在中序遍历中，4，7均在2的左边，则4，7均为以2为根树的左子树，且没有右子树； 对于4，7这两个节点来说，先序遍历中，4节点在7节点之前，所以4为根节点，而7作为子树，在中序遍历中，7在4之后，所以7为右子树； 对于根节点1的右子树5，3，8，6来说，在先序遍历中，3在最前面，所以3为这棵子树的根节点，而在中序遍历中，5在3的左边，所以属于左子树，而8，6在3的右边，属于右子树； 对于根节点3的右子树8，6，在先序遍历中，6在8之前，所以，6又为根节点，而在中序遍历中，8在6的左边，所以8是6的左子节点； 至此，二叉树便重建完成； 代码树的节点123456789public class TreeNode &#123; int val; //当前节点的值 TreeNode left; //左子节点 TreeNode right; //右子节点 TreeNode(int x) &#123; val = x; &#125;&#125; 建树方法1234567891011121314151617181920212223242526272829303132/*** pre：线序遍历得到的数组* in：中序遍历得到的数组*/public TreeNode reConstructBinaryTree(int[] pre, int[] in) &#123; if(pre.length == 0) &#123; return null; &#125; int root = pre[0]; TreeNode node = new TreeNode(root); //寻找根节点在in中的索引 int i = 0; for( ; i&lt;in.length; ++i) &#123; if(in[i] == root) &#123; break; &#125; &#125; //建立左子树 int[] leftIn = Arrays.copyOfRange(in, 0, i); int[] leftPre = Arrays.copyOfRange(pre, 1, i+1); node.left = reConstructBinaryTree(leftPre, leftIn); //建立右子树 int[] rightIn = Arrays.copyOfRange(in, i+1, in.length); int[] rightPre = Arrays.copyOfRange(pre, i+1, pre.length); node.right = reConstructBinaryTree(rightPre, rightIn); return node;&#125; 建树代码（优化）1234567891011121314151617181920212223242526272829public TreeNode reConstructBinaryTree(int[] pre, int[] in) &#123; return getRootTreeNode(pre, 0, pre.length-1, in, 0, in.length-1);&#125;/*** preL：当前子树在先序遍历的数组中的起始下标* preR：当前子树在先序遍历的数组中的结束下标* inL：当前子树在中序遍历的数组中的起始下标* inR：当前子树在中序遍历的数组中的起始下标*/public TreeNode getRootTreeNode(int[] pre, int preL, int preR, int[] in, int inL, int inR) &#123; if(preL &gt; preR) &#123; return null; &#125; TreeNode node = new TreeNode(pre[preL]); for(int i=inL; i&lt;=inR; ++i) &#123; if(in[i] == pre[preL]) &#123; node.left = getRootTreeNode(pre, preL+1, preL+i-inL, in, inL, i-1); node.right = getRootTreeNode(pre, preL+i-inL+1, preR, in, i+1, inR); break; &#125; &#125; return node;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tewuyiang.github.io/categories/数据结构与算法/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tewuyiang.github.io/tags/数据结构与算法/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-07-20T13:16:12.966Z","updated":"2019-07-20T13:16:12.967Z","comments":true,"path":"hello-world/","link":"","permalink":"https://tewuyiang.github.io/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}